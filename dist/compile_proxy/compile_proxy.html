<!DOCTYPE html><html><head>
    <title>Compile proxy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    
  <script id="jsenv_inject_systemjs">/*
* SJS 6.11.0
* Minimal SystemJS Build
*/
(function () {

  function errMsg(errCode, msg) {
    return (msg || "") + " (SystemJS https://git.io/JvFET#" + errCode + ")";
  }

  var hasSymbol = typeof Symbol !== 'undefined';
  var hasSelf = typeof self !== 'undefined';
  var hasDocument = typeof document !== 'undefined';

  var envGlobal = hasSelf ? self : global;

  var baseUrl;

  if (hasDocument) {
    var baseEl = document.querySelector('base[href]');
    if (baseEl)
      baseUrl = baseEl.href;
  }

  if (!baseUrl && typeof location !== 'undefined') {
    baseUrl = location.href.split('#')[0].split('?')[0];
    var lastSepIndex = baseUrl.lastIndexOf('/');
    if (lastSepIndex !== -1)
      baseUrl = baseUrl.slice(0, lastSepIndex + 1);
  }

  var backslashRegEx = /\\/g;
  function resolveIfNotPlainOrUrl (relUrl, parentUrl) {
    if (relUrl.indexOf('\\') !== -1)
      relUrl = relUrl.replace(backslashRegEx, '/');
    // protocol-relative
    if (relUrl[0] === '/' && relUrl[1] === '/') {
      return parentUrl.slice(0, parentUrl.indexOf(':') + 1) + relUrl;
    }
    // relative-url
    else if (relUrl[0] === '.' && (relUrl[1] === '/' || relUrl[1] === '.' && (relUrl[2] === '/' || relUrl.length === 2 && (relUrl += '/')) ||
        relUrl.length === 1  && (relUrl += '/')) ||
        relUrl[0] === '/') {
      var parentProtocol = parentUrl.slice(0, parentUrl.indexOf(':') + 1);
      // Disabled, but these cases will give inconsistent results for deep backtracking
      //if (parentUrl[parentProtocol.length] !== '/')
      //  throw Error('Cannot resolve');
      // read pathname from parent URL
      // pathname taken to be part after leading "/"
      var pathname;
      if (parentUrl[parentProtocol.length + 1] === '/') {
        // resolving to a :// so we need to read out the auth and host
        if (parentProtocol !== 'file:') {
          pathname = parentUrl.slice(parentProtocol.length + 2);
          pathname = pathname.slice(pathname.indexOf('/') + 1);
        }
        else {
          pathname = parentUrl.slice(8);
        }
      }
      else {
        // resolving to :/ so pathname is the /... part
        pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === '/'));
      }

      if (relUrl[0] === '/')
        return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl;

      // join together and split for removal of .. and . segments
      // looping the string instead of anything fancy for perf reasons
      // '../../../../../z' resolved to 'x/y' is just 'z'
      var segmented = pathname.slice(0, pathname.lastIndexOf('/') + 1) + relUrl;

      var output = [];
      var segmentIndex = -1;
      for (var i = 0; i < segmented.length; i++) {
        // busy reading a segment - only terminate on '/'
        if (segmentIndex !== -1) {
          if (segmented[i] === '/') {
            output.push(segmented.slice(segmentIndex, i + 1));
            segmentIndex = -1;
          }
        }

        // new segment - check if it is relative
        else if (segmented[i] === '.') {
          // ../ segment
          if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {
            output.pop();
            i += 2;
          }
          // ./ segment
          else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {
            i += 1;
          }
          else {
            // the start of a new segment as below
            segmentIndex = i;
          }
        }
        // it is the start of a new segment
        else {
          segmentIndex = i;
        }
      }
      // finish reading out the last segment
      if (segmentIndex !== -1)
        output.push(segmented.slice(segmentIndex));
      return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join('');
    }
  }

  /*
   * Import maps implementation
   *
   * To make lookups fast we pre-resolve the entire import map
   * and then match based on backtracked hash lookups
   *
   */

  function resolveUrl (relUrl, parentUrl) {
    return resolveIfNotPlainOrUrl(relUrl, parentUrl) || (relUrl.indexOf(':') !== -1 ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
  }

  function resolveAndComposePackages (packages, outPackages, baseUrl, parentMap, parentUrl) {
    for (var p in packages) {
      var resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
      var rhs = packages[p];
      // package fallbacks not currently supported
      if (typeof rhs !== 'string')
        continue;
      var mapped = resolveImportMap(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
      if (!mapped) {
        targetWarning('W1', p, rhs);
      }
      else
        outPackages[resolvedLhs] = mapped;
    }
  }

  function resolveAndComposeImportMap (json, baseUrl, outMap) {
    if (json.imports)
      resolveAndComposePackages(json.imports, outMap.imports, baseUrl, outMap, null);

    var u;
    for (u in json.scopes || {}) {
      var resolvedScope = resolveUrl(u, baseUrl);
      resolveAndComposePackages(json.scopes[u], outMap.scopes[resolvedScope] || (outMap.scopes[resolvedScope] = {}), baseUrl, outMap, resolvedScope);
    }

    for (u in json.depcache || {})
      outMap.depcache[resolveUrl(u, baseUrl)] = json.depcache[u];

    for (u in json.integrity || {})
      outMap.integrity[resolveUrl(u, baseUrl)] = json.integrity[u];
  }

  function getMatch (path, matchObj) {
    if (matchObj[path])
      return path;
    var sepIndex = path.length;
    do {
      var segment = path.slice(0, sepIndex + 1);
      if (segment in matchObj)
        return segment;
    } while ((sepIndex = path.lastIndexOf('/', sepIndex - 1)) !== -1)
  }

  function applyPackages (id, packages) {
    var pkgName = getMatch(id, packages);
    if (pkgName) {
      var pkg = packages[pkgName];
      if (pkg === null) return;
      if (id.length > pkgName.length && pkg[pkg.length - 1] !== '/') {
        targetWarning('W2', pkgName, pkg);
      }
      else
        return pkg + id.slice(pkgName.length);
    }
  }

  function targetWarning (code, match, target, msg) {
    console.warn(errMsg(code,  [target, match].join(', ') ));
  }

  function resolveImportMap (importMap, resolvedOrPlain, parentUrl) {
    var scopes = importMap.scopes;
    var scopeUrl = parentUrl && getMatch(parentUrl, scopes);
    while (scopeUrl) {
      var packageResolution = applyPackages(resolvedOrPlain, scopes[scopeUrl]);
      if (packageResolution)
        return packageResolution;
      scopeUrl = getMatch(scopeUrl.slice(0, scopeUrl.lastIndexOf('/')), scopes);
    }
    return applyPackages(resolvedOrPlain, importMap.imports) || resolvedOrPlain.indexOf(':') !== -1 && resolvedOrPlain;
  }

  /*
   * SystemJS Core
   *
   * Provides
   * - System.import
   * - System.register support for
   *     live bindings, function hoisting through circular references,
   *     reexports, dynamic import, import.meta.url, top-level await
   * - System.getRegister to get the registration
   * - Symbol.toStringTag support in Module objects
   * - Hookable System.createContext to customize import.meta
   * - System.onload(err, id, deps) handler for tracing / hot-reloading
   *
   * Core comes with no System.prototype.resolve or
   * System.prototype.instantiate implementations
   */

  var toStringTag = hasSymbol && Symbol.toStringTag;
  var REGISTRY = hasSymbol ? Symbol() : '@';

  function SystemJS () {
    this[REGISTRY] = {};
  }

  var systemJSPrototype = SystemJS.prototype;

  systemJSPrototype.import = function (id, parentUrl) {
    var loader = this;
    return Promise.resolve(loader.prepareImport())
    .then(function() {
      return loader.resolve(String(id), parentUrl);
    })
    .then(function (id) {
      var load = getOrCreateLoad(loader, id);
      return load.C || topLevelLoad(loader, load);
    });
  };

  // Hookable createContext function -> allowing eg custom import meta
  systemJSPrototype.createContext = function (parentId) {
    var loader = this;
    return {
      url: parentId,
      resolve: function (id, parentUrl) {
        return Promise.resolve(loader.resolve(id, parentUrl || parentId));
      }
    };
  };
  function loadToId (load) {
    return load.id;
  }
  function triggerOnload (loader, load, err, isErrSource) {
    loader.onload(err, load.id, load.d && load.d.map(loadToId), !!isErrSource);
    if (err)
      throw err;
  }

  var lastRegister;
  systemJSPrototype.register = function (deps, declare) {
    lastRegister = [deps, declare];
  };

  /*
   * getRegister provides the last anonymous System.register call
   */
  systemJSPrototype.getRegister = function () {
    var _lastRegister = lastRegister;
    lastRegister = undefined;
    return _lastRegister;
  };

  function getOrCreateLoad (loader, id, firstParentUrl) {
    var load = loader[REGISTRY][id];
    if (load)
      return load;

    var importerSetters = [];
    var ns = Object.create(null);
    if (toStringTag)
      Object.defineProperty(ns, toStringTag, { value: 'Module' });

    var instantiatePromise = Promise.resolve()
    .then(function () {
      return loader.instantiate(id, firstParentUrl);
    })
    .then(function (registration) {
      if (!registration)
        throw Error(errMsg(2,  id ));
      function _export (name, value) {
        // note if we have hoisted exports (including reexports)
        load.h = true;
        var changed = false;
        if (typeof name === 'string') {
          if (!(name in ns) || ns[name] !== value) {
            ns[name] = value;
            changed = true;
          }
        }
        else {
          for (var p in name) {
            var value = name[p];
            if (!(p in ns) || ns[p] !== value) {
              ns[p] = value;
              changed = true;
            }
          }

          if (name && name.__esModule) {
            ns.__esModule = name.__esModule;
          }
        }
        if (changed)
          for (var i = 0; i < importerSetters.length; i++) {
            var setter = importerSetters[i];
            if (setter) setter(ns);
          }
        return value;
      }
      var declared = registration[1](_export, registration[1].length === 2 ? {
        import: function (importId) {
          return loader.import(importId, id);
        },
        meta: loader.createContext(id)
      } : undefined);
      load.e = declared.execute || function () {};
      return [registration[0], declared.setters || []];
    }, function (err) {
      load.e = null;
      load.er = err;
      throw err;
    });

    var linkPromise = instantiatePromise
    .then(function (instantiation) {
      return Promise.all(instantiation[0].map(function (dep, i) {
        var setter = instantiation[1][i];
        return Promise.resolve(loader.resolve(dep, id))
        .then(function (depId) {
          var depLoad = getOrCreateLoad(loader, depId, id);
          // depLoad.I may be undefined for already-evaluated
          return Promise.resolve(depLoad.I)
          .then(function () {
            if (setter) {
              depLoad.i.push(setter);
              // only run early setters when there are hoisted exports of that module
              // the timing works here as pending hoisted export calls will trigger through importerSetters
              if (depLoad.h || !depLoad.I)
                setter(depLoad.n);
            }
            return depLoad;
          });
        });
      }))
      .then(function (depLoads) {
        load.d = depLoads;
      });
    });

    // Capital letter = a promise function
    return load = loader[REGISTRY][id] = {
      id: id,
      // importerSetters, the setters functions registered to this dependency
      // we retain this to add more later
      i: importerSetters,
      // module namespace object
      n: ns,

      // instantiate
      I: instantiatePromise,
      // link
      L: linkPromise,
      // whether it has hoisted exports
      h: false,

      // On instantiate completion we have populated:
      // dependency load records
      d: undefined,
      // execution function
      e: undefined,

      // On execution we have populated:
      // the execution error if any
      er: undefined,
      // in the case of TLA, the execution promise
      E: undefined,

      // On execution, L, I, E cleared

      // Promise for top-level completion
      C: undefined,

      // parent instantiator / executor
      p: undefined
    };
  }

  function instantiateAll (loader, load, parent, loaded) {
    if (!loaded[load.id]) {
      loaded[load.id] = true;
      // load.L may be undefined for already-instantiated
      return Promise.resolve(load.L)
      .then(function () {
        if (!load.p || load.p.e === null)
          load.p = parent;
        return Promise.all(load.d.map(function (dep) {
          return instantiateAll(loader, dep, parent, loaded);
        }));
      })
      .catch(function (err) {
        if (load.er)
          throw err;
        load.e = null;
        throw err;
      });
    }
  }

  function topLevelLoad (loader, load) {
    return load.C = instantiateAll(loader, load, load, {})
    .then(function () {
      return postOrderExec(loader, load, {});
    })
    .then(function () {
      return load.n;
    });
  }

  // the closest we can get to call(undefined)
  var nullContext = Object.freeze(Object.create(null));

  // returns a promise if and only if a top-level await subgraph
  // throws on sync errors
  function postOrderExec (loader, load, seen) {
    if (seen[load.id])
      return;
    seen[load.id] = true;

    if (!load.e) {
      if (load.er)
        throw load.er;
      if (load.E)
        return load.E;
      return;
    }

    // deps execute first, unless circular
    var depLoadPromises;
    load.d.forEach(function (depLoad) {
      try {
        var depLoadPromise = postOrderExec(loader, depLoad, seen);
        if (depLoadPromise)
          (depLoadPromises = depLoadPromises || []).push(depLoadPromise);
      }
      catch (err) {
        load.e = null;
        load.er = err;
        throw err;
      }
    });
    if (depLoadPromises)
      return Promise.all(depLoadPromises).then(doExec);

    return doExec();

    function doExec () {
      try {
        var execPromise = load.e.call(nullContext);
        if (execPromise) {
          execPromise = execPromise.then(function () {
            load.C = load.n;
            load.E = null; // indicates completion
            if (!true) ;
          }, function (err) {
            load.er = err;
            load.E = null;
            if (!true) ;
            throw err;
          });
          return load.E = execPromise;
        }
        // (should be a promise, but a minify optimization to leave out Promise.resolve)
        load.C = load.n;
        load.L = load.I = undefined;
      }
      catch (err) {
        load.er = err;
        throw err;
      }
      finally {
        load.e = null;
      }
    }
  }

  envGlobal.System = new SystemJS();

  /*
   * SystemJS browser attachments for script and import map processing
   */

  var importMapPromise = Promise.resolve();
  var importMap = { imports: {}, scopes: {}, depcache: {}, integrity: {} };
  systemJSPrototype.importMap = importMap;
  systemJSPrototype.baseUrl = baseUrl;

  // Scripts are processed immediately, on the first System.import, and on DOMReady.
  // Import map scripts are processed only once (by being marked) and in order for each phase.
  // This is to avoid using DOM mutation observers in core, although that would be an alternative.
  var processFirst = hasDocument;
  systemJSPrototype.prepareImport = function (doProcessScripts) {
    if (processFirst || doProcessScripts) {
      processScripts();
      processFirst = false;
    }
    return importMapPromise;
  };
  if (hasDocument) {
    processScripts();
    window.addEventListener('DOMContentLoaded', processScripts);
  }

  function processScripts () {
    [].forEach.call(document.querySelectorAll('script'), function (script) {
      if (script.sp) // sp marker = systemjs processed
        return;
      // TODO: deprecate systemjs-module in next major now that we have auto import
      if (script.type === 'systemjs-module') {
        script.sp = true;
        if (!script.src)
          return;
        System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : resolveUrl(script.src, baseUrl)).catch(function (e) {
          // if there is a script load error, dispatch an "error" event
          // on the script tag.
          if (e.message.indexOf('https://git.io/JvFET#3') > -1) {
            var event = document.createEvent('Event');
            event.initEvent('error', false, false);
            script.dispatchEvent(event);
          }
          return Promise.reject(e);
        });
      }
      else if (script.type === 'systemjs-importmap') {
        script.sp = true;
        var fetchPromise = script.src ? fetch(script.src, { integrity: script.integrity }).then(function (res) {
          if (!res.ok)
            throw Error( res.status );
          return res.text();
        }).catch(function (err) {
          err.message = errMsg('W4',  script.src ) + '\n' + err.message;
          console.warn(err);
          if (typeof script.onerror === 'function') {
              script.onerror();
          }
          return '{}';
        }) : script.innerHTML;
        importMapPromise = importMapPromise.then(function () {
          return fetchPromise;
        }).then(function (text) {
          extendImportMap(importMap, text, script.src || baseUrl);
          return importMap
        });
      }
    });
  }

  function extendImportMap (importMap, newMapText, newMapUrl) {
    var newMap = {};
    try {
      newMap = JSON.parse(newMapText);
    } catch (err) {
      console.warn(Error(( errMsg('W5')  )));
    }
    resolveAndComposeImportMap(newMap, newMapUrl, importMap);
  }
  System.extendImportMap = extendImportMap

  /*
   * Script instantiation loading
   */

  if (hasDocument) {
    window.addEventListener('error', function (evt) {
      lastWindowErrorUrl = evt.filename;
      lastWindowError = evt.error;
    });
    var baseOrigin = location.origin;
  }

  systemJSPrototype.createScript = function (url) {
    var script = document.createElement('script');
    script.async = true;
    // Only add cross origin for actual cross origin
    // this is because Safari triggers for all
    // - https://bugs.webkit.org/show_bug.cgi?id=171566
    if (url.indexOf(baseOrigin + '/'))
      script.crossOrigin = 'anonymous';
    var integrity = importMap.integrity[url];
    if (integrity)
      script.integrity = integrity;
    script.src = url;
    return script;
  };

  // Auto imports -> script tags can be inlined directly for load phase
  var lastAutoImportDeps, lastAutoImportTimeout;
  var autoImportCandidates = {};
  var systemRegister = systemJSPrototype.register;
  var inlineScriptCount = 0;
  systemJSPrototype.register = function (deps, declare, autoUrl) {
    if (hasDocument && document.readyState === 'loading' && typeof deps !== 'string') {
      var scripts = document.querySelectorAll('script[src]');
      var lastScript = scripts[scripts.length - 1];
      var lastAutoImportUrl
      lastAutoImportDeps = deps;
      if (lastScript && lastScript.src) {
        lastAutoImportUrl = lastScript.src;
      }
      else if (autoUrl) {
        lastAutoImportUrl = autoUrl
      }
      else {
        inlineScriptCount++
        lastAutoImportUrl = document.location.href + "__inline_script__" + inlineScriptCount;
      }
      // if this is already a System load, then the instantiate has already begun
      // so this re-import has no consequence
      var loader = this;
      lastAutoImportTimeout = setTimeout(function () {
        autoImportCandidates[lastAutoImportUrl] = [deps, declare];
        loader.import(lastAutoImportUrl);
      });
    }
    else {
      lastAutoImportDeps = undefined;
    }
    return systemRegister.call(this, deps, declare);
  };

  var lastWindowErrorUrl, lastWindowError;
  systemJSPrototype.instantiate = function (url, firstParentUrl) {
    var autoImportRegistration = autoImportCandidates[url];
    if (autoImportRegistration) {
      delete autoImportCandidates[url];
      return autoImportRegistration;
    }
    var loader = this;
    return Promise.resolve(systemJSPrototype.createScript(url)).then(function (script) {
      return new Promise(function (resolve, reject) {
        script.addEventListener('error', function () {
          reject(Error(errMsg(3,  [url, firstParentUrl].join(', ') )));
        });
        script.addEventListener('load', function () {
          document.head.removeChild(script);
          // Note that if an error occurs that isn't caught by this if statement,
          // that getRegister will return null and a "did not instantiate" error will be thrown.
          if (lastWindowErrorUrl === url) {
            reject(lastWindowError);
          }
          else {
            var register = loader.getRegister(url);
            // Clear any auto import registration for dynamic import scripts during load
            if (register && register[0] === lastAutoImportDeps)
              clearTimeout(lastAutoImportTimeout);
            resolve(register);
          }
        });
        document.head.appendChild(script);
      });
    });
  };

  /*
   * Fetch loader, sets up shouldFetch and fetch hooks
   */
  systemJSPrototype.shouldFetch = function () {
    return false;
  };
  if (typeof fetch !== 'undefined')
    systemJSPrototype.fetch = fetch;

  var instantiate = systemJSPrototype.instantiate;
  var jsContentTypeRegEx = /^(text|application)\/(x-)?javascript(;|$)/;
  systemJSPrototype.instantiate = function (url, parent) {
    var loader = this;
    if (!this.shouldFetch(url))
      return instantiate.apply(this, arguments);
    return this.fetch(url, {
      credentials: 'same-origin',
      integrity: importMap.integrity[url]
    })
    .then(function (res) {
      if (!res.ok)
        throw Error(errMsg(7,  [res.status, res.statusText, url, parent].join(', ') ));
      var contentType = res.headers.get('content-type');
      if (!contentType || !jsContentTypeRegEx.test(contentType))
        throw Error(errMsg(4,  contentType ));
      return res.text().then(function (source) {
        if (source.indexOf('//# sourceURL=') < 0)
          source += '\n//# sourceURL=' + url;
        (0, eval)(source);
        return loader.getRegister(url);
      });
    });
  };

  systemJSPrototype.resolve = function (id, parentUrl) {
    parentUrl = parentUrl || !true  || baseUrl;
    return resolveImportMap(( importMap), resolveIfNotPlainOrUrl(id, parentUrl) || id, parentUrl) || throwUnresolved(id, parentUrl);
  };

  function throwUnresolved (id, parentUrl) {
    throw Error(errMsg(8,  [id, parentUrl].join(', ') ));
  }

  var systemInstantiate = systemJSPrototype.instantiate;
  systemJSPrototype.instantiate = function (url, firstParentUrl) {
    var preloads = ( importMap).depcache[url];
    if (preloads) {
      for (var i = 0; i < preloads.length; i++)
        getOrCreateLoad(this, this.resolve(preloads[i], url), url);
    }
    return systemInstantiate.call(this, url, firstParentUrl);
  };

  /*
   * Supports loading System.register in workers
   */

  if (hasSelf && typeof importScripts === 'function') {
    systemJSPrototype.instantiate = function (url) {
      var loader = this;
      return self.fetch(url, {
        credentials: 'same-origin',
      }).then(function (response) {
        if (!response.ok) {
          throw Error(errMsg(7,  [response.status, response.statusText, url].join(', ') ));
        }
        return response.text()
      }).then(function (source) {
        if (source.indexOf('//# sourceURL=') < 0) source += '\n//# sourceURL=' + url;
        (0, eval)(source);
        return loader.getRegister(url);
      })
    };
  }

}());

(function(){
  var envGlobal = typeof self !== 'undefined' ? self : global;
  var System = envGlobal.System;

  var registerRegistry = Object.create(null)
  var register = System.register;
  System.registerRegistry = registerRegistry;
  System.register = function (name, deps, declare) {
    if (typeof name !== 'string') return register.apply(this, arguments);
    var define = [deps, declare];
    return System.prepareImport().then(function () {
      var url = System.resolve(`./${name}`);
      registerRegistry[url] = define;
      return register.call(System, deps, declare, url);
    })
  };

  var instantiate = System.instantiate;
  System.instantiate = function (url, firstParentUrl) {
    var result = registerRegistry[url];

    if (result) {
      registerRegistry[url] = null;
      return result;
    } else {
      return instantiate.call(this, url, firstParentUrl);
    }
  };

  var getRegister = System.getRegister;
  System.getRegister = function (url) {
    // Calling getRegister() because other extras need to know it was called so they can perform side effects
    var register = getRegister.call(this, url);
    var result = registerRegistry[url] || register;
    return result;
  };
}());

(function () {
  // worker or service worker
  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {
    var importMapFromParentPromise = new Promise((resolve) => {
      var importmapMessageCallback = function (e) {
        if (e.data === "__importmap_init__") {
          self.removeEventListener("message", importmapMessageCallback)
          e.ports[0].onmessage = (message) => {
            resolve(message.data)
          }
          e.ports[0].postMessage('__importmap_request__')         
        }
      };
      self.addEventListener("message", importmapMessageCallback)
    })
    // var prepareImport = System.prepareImport
    System.prepareImport = function () {
      return importMapFromParentPromise.then(function (importmap) {
        System.extendImportMap(System.importMap, JSON.stringify(importmap), System.baseUrl)
      })
    }

    // auto import first register
    var messageEvents = []
    var messageCallback = (event) => {
      messageEvents.push(event)
    }
    self.addEventListener('message', messageCallback)
    var register = System.register;
    System.register = function(deps, declare) {
      System.register = register;
      System.registerRegistry[self.location.href] = [deps, declare];
      return System.import(self.location.href).then((result) => {
        self.removeEventListener('message', messageCallback)
        messageEvents.forEach((messageEvent) => {
          self.dispatchEvent(messageEvent)
        })
        messageEvents = null
        return result
      })
    }
  }
  else if (typeof window === 'object') {
    var WorkerConstructor = window.Worker;
    if (typeof WorkerConstructor === 'function') {
      window.Worker = function (url, options) {
        var worker = new WorkerConstructor(url, options);
        var importmapChannel = new MessageChannel();
        importmapChannel.port1.onmessage = function (message) {
          System.prepareImport().then(function (importmap) {
            message.target.postMessage(importmap);
          });
        }
        worker.postMessage('__importmap_init__', [importmapChannel.port2]);
        return worker
      }
    }

    var serviceWorker = navigator.serviceWorker;
    if (serviceWorker) {
      var register =  serviceWorker.register;
      serviceWorker.register = function(url, options) {
        var registrationPromise = register.call(this, url, options);
        registrationPromise.then(function(registration) {
          var installing = registration.installing;
          var waiting = registration.waiting;
          var active = registration.active;
          var worker = installing || waiting || active;
          var importmapChannel = new MessageChannel();
          importmapChannel.port1.onmessage = function (message) {
            System.prepareImport().then(function (importmap) {
              message.target.postMessage(importmap)
            });
          }
          worker.postMessage('__importmap_init__', [importmapChannel.port2]);
        })
        return registrationPromise
      }
    }
  }
}());</script>
      </head>

  <body>
    <script>
      window.readyPromise = new Promise((resolve) => {
        window.resolveReadyPromise = resolve
      })
    </script>
    <script type="systemjs-importmap">{
  "imports": {}
}</script>
    <script>System.register("compile_proxy.html__inline__20.js", [], (function () {
  'use strict';
  return {
    execute: (function () {

      const fetchUsingXHR = async (url, {
        signal,
        method = "GET",
        credentials = "same-origin",
        headers = {},
        body = null
      } = {}) => {
        const headersPromise = createPromiseAndHooks();
        const bodyPromise = createPromiseAndHooks();
        const xhr = new XMLHttpRequest();

        const failure = error => {
          // if it was already resolved, we must reject the body promise
          if (headersPromise.settled) {
            bodyPromise.reject(error);
          } else {
            headersPromise.reject(error);
          }
        };

        const cleanup = () => {
          xhr.ontimeout = null;
          xhr.onerror = null;
          xhr.onload = null;
          xhr.onreadystatechange = null;
        };

        xhr.ontimeout = () => {
          cleanup();
          failure(new Error(`xhr request timeout on ${url}.`));
        };

        xhr.onerror = error => {
          cleanup(); // unfortunately with have no clue why it fails
          // might be cors for instance

          failure(createRequestError(error, {
            url
          }));
        };

        xhr.onload = () => {
          cleanup();
          bodyPromise.resolve();
        };

        signal.addEventListener("abort", () => {
          xhr.abort();
          const abortError = new Error("aborted");
          abortError.name = "AbortError";
          failure(abortError);
        });

        xhr.onreadystatechange = () => {
          // https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/readyState
          const {
            readyState
          } = xhr;

          if (readyState === 2) {
            headersPromise.resolve();
          } else if (readyState === 4) {
            cleanup();
            bodyPromise.resolve();
          }
        };

        xhr.open(method, url, true);
        Object.keys(headers).forEach(key => {
          xhr.setRequestHeader(key, headers[key]);
        });
        xhr.withCredentials = computeWithCredentials({
          credentials,
          url
        });

        if ("responseType" in xhr && hasBlob) {
          xhr.responseType = "blob";
        }

        xhr.send(body);
        await headersPromise; // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseURL

        const responseUrl = "responseURL" in xhr ? xhr.responseURL : headers["x-request-url"];
        let responseStatus = xhr.status;
        const responseStatusText = xhr.statusText;
        const responseHeaders = getHeadersFromXHR(xhr);

        const readBody = async () => {
          await bodyPromise;
          const {
            status
          } = xhr; // in Chrome on file:/// URLs, status is 0

          if (status === 0) {
            responseStatus = 200;
          }

          const body = "response" in xhr ? xhr.response : xhr.responseText;
          return {
            responseBody: body,
            responseBodyType: detectBodyType(body)
          };
        };

        const text = async () => {
          const {
            responseBody,
            responseBodyType
          } = await readBody();

          if (responseBodyType === "blob") {
            return blobToText(responseBody);
          }

          if (responseBodyType === "formData") {
            throw new Error("could not read FormData body as text");
          }

          if (responseBodyType === "dataView") {
            return arrayBufferToText(responseBody.buffer);
          }

          if (responseBodyType === "arrayBuffer") {
            return arrayBufferToText(responseBody);
          } // if (responseBodyType === "text" || responseBodyType === 'searchParams') {
          //   return body
          // }


          return String(responseBody);
        };

        const json = async () => {
          const responseText = await text();
          return JSON.parse(responseText);
        };

        const blob = async () => {
          if (!hasBlob) {
            throw new Error(`blob not supported`);
          }

          const {
            responseBody,
            responseBodyType
          } = await readBody();

          if (responseBodyType === "blob") {
            return responseBody;
          }

          if (responseBodyType === "dataView") {
            return new Blob([cloneBuffer(responseBody.buffer)]);
          }

          if (responseBodyType === "arrayBuffer") {
            return new Blob([cloneBuffer(responseBody)]);
          }

          if (responseBodyType === "formData") {
            throw new Error("could not read FormData body as blob");
          }

          return new Blob([String(responseBody)]);
        };

        const arrayBuffer = async () => {
          const {
            responseBody,
            responseBodyType
          } = await readBody();

          if (responseBodyType === "arrayBuffer") {
            return cloneBuffer(responseBody);
          }

          const responseBlob = await blob();
          return blobToArrayBuffer(responseBlob);
        };

        const formData = async () => {
          if (!hasFormData) {
            throw new Error(`formData not supported`);
          }

          const responseText = await text();
          return textToFormData(responseText);
        };

        return {
          url: responseUrl,
          status: responseStatus,
          statusText: responseStatusText,
          headers: responseHeaders,
          text,
          json,
          blob,
          arrayBuffer,
          formData
        };
      };

      const canUseBlob = () => {
        if (typeof window.FileReader !== "function") return false;
        if (typeof window.Blob !== "function") return false;

        try {
          // eslint-disable-next-line no-new
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      };

      const hasBlob = canUseBlob();
      const hasFormData = typeof window.FormData === "function";
      const hasArrayBuffer = typeof window.ArrayBuffer === "function";
      const hasSearchParams = typeof window.URLSearchParams === "function";

      const createRequestError = (error, {
        url
      }) => {
        return new Error(`error during xhr request on ${url}.
--- error stack ---
${error.stack}`);
      };

      const createPromiseAndHooks = () => {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = value => {
            promise.settled = true;
            res(value);
          };

          reject = value => {
            promise.settled = true;
            rej(value);
          };
        });
        promise.resolve = resolve;
        promise.reject = reject;
        return promise;
      }; // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch


      const computeWithCredentials = ({
        credentials,
        url
      }) => {
        if (credentials === "same-origin") {
          return originSameAsGlobalOrigin(url);
        }

        return credentials === "include";
      };

      const originSameAsGlobalOrigin = url => {
        // if we cannot read globalOrigin from window.location.origin, let's consider it's ok
        if (typeof window !== "object") return true;
        if (typeof window.location !== "object") return true;
        const globalOrigin = window.location.origin;
        if (globalOrigin === "null") return true;
        return hrefToOrigin(url) === globalOrigin;
      };

      const detectBodyType = body => {
        if (!body) {
          return "";
        }

        if (typeof body === "string") {
          return "text";
        }

        if (hasBlob && Blob.prototype.isPrototypeOf(body)) {
          return "blob";
        }

        if (hasFormData && FormData.prototype.isPrototypeOf(body)) {
          return "formData";
        }

        if (hasArrayBuffer) {
          if (hasBlob && isDataView(body)) {
            return `dataView`;
          }

          if (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body)) {
            return `arrayBuffer`;
          }
        }

        if (hasSearchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          return "searchParams";
        }

        return "";
      }; // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example


      const getHeadersFromXHR = xhr => {
        const headerMap = {};
        const headersString = xhr.getAllResponseHeaders();
        if (headersString === "") return headerMap;
        const lines = headersString.trim().split(/[\r\n]+/);
        lines.forEach(line => {
          const parts = line.split(": ");
          const name = parts.shift();
          const value = parts.join(": ");
          headerMap[name.toLowerCase()] = value;
        });
        return headerMap;
      };

      const hrefToOrigin = href => {
        const scheme = hrefToScheme(href);

        if (scheme === "file") {
          return "file://";
        }

        if (scheme === "http" || scheme === "https") {
          const secondProtocolSlashIndex = scheme.length + "://".length;
          const pathnameSlashIndex = href.indexOf("/", secondProtocolSlashIndex);
          if (pathnameSlashIndex === -1) return href;
          return href.slice(0, pathnameSlashIndex);
        }

        return href.slice(0, scheme.length + 1);
      };

      const hrefToScheme = href => {
        const colonIndex = href.indexOf(":");
        if (colonIndex === -1) return "";
        return href.slice(0, colonIndex);
      };

      const isDataView = obj => {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };

      const isArrayBufferView = ArrayBuffer.isView || (() => {
        const viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
        return value => {
          return value && viewClasses.includes(Object.prototype.toString.call(value));
        };
      })();

      const textToFormData = text => {
        const form = new FormData();
        text.trim().split("&").forEach(function (bytes) {
          if (bytes) {
            const split = bytes.split("=");
            const name = split.shift().replace(/\+/g, " ");
            const value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      };

      const blobToArrayBuffer = async blob => {
        const reader = new FileReader();
        const promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      };

      const blobToText = blob => {
        const reader = new FileReader();
        const promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      };

      const arrayBufferToText = arrayBuffer => {
        const view = new Uint8Array(arrayBuffer);
        const chars = new Array(view.length);
        let i = 0;

        while (i < view.length) {
          chars[i] = String.fromCharCode(view[i]);
          i++;
        }

        return chars.join("");
      };

      const fileReaderReady = reader => {
        return new Promise(function (resolve, reject) {
          reader.onload = function () {
            resolve(reader.result);
          };

          reader.onerror = function () {
            reject(reader.error);
          };
        });
      };

      const cloneBuffer = buffer => {
        if (buffer.slice) {
          return buffer.slice(0);
        }

        const view = new Uint8Array(buffer.byteLength);
        view.set(new Uint8Array(buffer));
        return view.buffer;
      };

      const fetchNative = async (url, {
        mode = "cors",
        ...options
      } = {}) => {
        const response = await window.fetch(url, {
          mode,
          ...options
        });
        return {
          url: response.url,
          status: response.status,
          statusText: "",
          headers: responseToHeaders(response),
          text: () => response.text(),
          json: () => response.json(),
          blob: () => response.blob(),
          arrayBuffer: () => response.arrayBuffer(),
          formData: () => response.formData()
        };
      };

      const responseToHeaders = response => {
        const headers = {};
        response.headers.forEach((value, name) => {
          headers[name] = value;
        });
        return headers;
      };

      const fetchUrl = typeof window.fetch === "function" && typeof window.AbortController === "function" ? fetchNative : fetchUsingXHR;

      const fetchJson = async (url, options = {}) => {
        const response = await fetchUrl(url, options);
        const object = await response.json();
        return object;
      };

      /*
       * Prefer window.navigator.userAgentData before resorting to
       * window.navigator.userAgent because of
       * https://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-dates.html
       */
      const detectFromUserAgentData = () => {
        const {
          userAgentData
        } = window.navigator;

        if (!userAgentData) {
          return null;
        }

        const {
          brands
        } = userAgentData;
        let i = 0;

        while (i < brands.length) {
          const {
            brand,
            version
          } = brands[i];
          i++;

          if (brand === "chromium" || brand === "Google Chrome") {
            return {
              name: "chrome",
              version
            };
          }
        }

        return null;
      };

      const firstMatch = (regexp, string) => {
        const match = string.match(regexp);
        return match && match.length > 0 ? match[1] || undefined : undefined;
      };
      const secondMatch = (regexp, string) => {
        const match = string.match(regexp);
        return match && match.length > 1 ? match[2] || undefined : undefined;
      };
      const userAgentToVersion = userAgent => {
        return firstMatch(/version\/(\d+(\.?_?\d+)+)/i, userAgent) || undefined;
      };

      const detectAndroid = () => navigatorToBrowser$1(window.navigator);

      const navigatorToBrowser$1 = ({
        userAgent,
        appVersion
      }) => {
        if (/(android)/i.test(userAgent)) {
          return {
            name: "android",
            version: firstMatch(/Android (\d+(\.?_?\d+)+)/i, appVersion)
          };
        }

        return null;
      };

      const detectInternetExplorer = () => userAgentToBrowser$5(window.navigator.userAgent);

      const userAgentToBrowser$5 = userAgent => {
        if (/msie|trident/i.test(userAgent)) {
          return {
            name: "ie",
            version: firstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, userAgent)
          };
        }

        return null;
      };

      const detectOpera = () => userAgentToBrowser$4(window.navigator.userAgent);

      const userAgentToBrowser$4 = userAgent => {
        // opera below 13
        if (/opera/i.test(userAgent)) {
          return {
            name: "opera",
            version: userAgentToVersion(userAgent) || firstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, userAgent)
          };
        } // opera above 13


        if (/opr\/|opios/i.test(userAgent)) {
          return {
            name: "opera",
            version: firstMatch(/(?:opr|opios)[\s/](\S+)/i, userAgent) || userAgentToVersion(userAgent)
          };
        }

        return null;
      };

      const detectEdge = () => userAgentToBrowser$3(window.navigator.userAgent);

      const userAgentToBrowser$3 = userAgent => {
        if (/edg([ea]|ios)/i.test(userAgent)) {
          return {
            name: "edge",
            version: secondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, userAgent)
          };
        }

        return null;
      };

      const detectFirefox = () => userAgentToBrowser$2(window.navigator.userAgent);

      const userAgentToBrowser$2 = userAgent => {
        if (/firefox|iceweasel|fxios/i.test(userAgent)) {
          return {
            name: "firefox",
            version: firstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, userAgent)
          };
        }

        return null;
      };

      const detectChrome = () => {
        return userAgentToBrowser$1(window.navigator.userAgent);
      };

      const userAgentToBrowser$1 = userAgent => {
        if (/chromium/i.test(userAgent)) {
          return {
            name: "chrome",
            version: firstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, userAgent) || userAgentToVersion(userAgent)
          };
        }

        if (/chrome|crios|crmo/i.test(userAgent)) {
          return {
            name: "chrome",
            version: firstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, userAgent)
          };
        }

        return null;
      };

      const detectSafari = () => userAgentToBrowser(window.navigator.userAgent);

      const userAgentToBrowser = userAgent => {
        if (/safari|applewebkit/i.test(userAgent)) {
          return {
            name: "safari",
            version: userAgentToVersion(userAgent)
          };
        }

        return null;
      };

      const detectElectron = () => null; // TODO

      const detectIOS = () => navigatorToBrowser(window.navigator);

      const navigatorToBrowser = ({
        userAgent,
        appVersion
      }) => {
        if (/iPhone;/.test(userAgent)) {
          return {
            name: "ios",
            version: firstMatch(/OS (\d+(\.?_?\d+)+)/i, appVersion)
          };
        }

        if (/iPad;/.test(userAgent)) {
          return {
            name: "ios",
            version: firstMatch(/OS (\d+(\.?_?\d+)+)/i, appVersion)
          };
        }

        return null;
      };

      // https://github.com/Ahmdrza/detect-browser/blob/26254f85cf92795655a983bfd759d85f3de850c6/detect-browser.js#L1

      const detectorCompose = detectors => () => {
        let i = 0;

        while (i < detectors.length) {
          const detector = detectors[i];
          i++;
          const result = detector();

          if (result) {
            return result;
          }
        }

        return null;
      };

      const detector = detectorCompose([detectFromUserAgentData, // keep this first
      detectOpera, detectInternetExplorer, detectEdge, detectFirefox, detectChrome, detectSafari, detectElectron, detectIOS, detectAndroid]);
      const detectBrowser = () => {
        const {
          name = "other",
          version = "unknown"
        } = detector() || {};
        return {
          name: normalizeName(name),
          version: normalizeVersion(version)
        };
      };

      const normalizeName = name => {
        return name.toLowerCase();
      };

      const normalizeVersion = version => {
        if (version.indexOf(".") > -1) {
          const parts = version.split("."); // remove extraneous .

          return parts.slice(0, 3).join(".");
        }

        if (version.indexOf("_") > -1) {
          const parts = version.split("_"); // remove extraneous _

          return parts.slice(0, 3).join("_");
        }

        return version;
      };

      const executeWithScriptModuleInjection = code => {
        const scriptModule = document.createElement("script");
        scriptModule.type = "module";
        const loadPromise = new Promise((resolve, reject) => {
          scriptModule.onload = () => {
            document.body.removeChild(scriptModule);
            resolve();
          };

          scriptModule.onerror = () => {
            document.body.removeChild(scriptModule);
            reject();
          };

          document.body.appendChild(scriptModule);
        });
        scriptModule.src = asBase64Url(code);
        return loadPromise;
      };
      const asBase64Url = (text, mimeType = "application/javascript") => {
        return `data:${mimeType};base64,${window.btoa(text)}`;
      };

      const supportsImportmap = async ({
        remote = true
      } = {}) => {
        const specifier = asBase64Url(`export default false`);
        const importMap = {
          imports: {
            [specifier]: asBase64Url(`export default true`)
          }
        };
        const importmapScript = document.createElement("script");
        const importmapString = JSON.stringify(importMap, null, "  ");
        importmapScript.type = "importmap";

        if (remote) {
          importmapScript.src = `data:application/json;base64,${window.btoa(importmapString)}`;
        } else {
          importmapScript.textContent = importmapString;
        }

        document.body.appendChild(importmapScript);

        try {
          await executeWithScriptModuleInjection(`import supported from "${specifier}"; window.__jsenv_runtime_test_importmap__ = supported`);
          document.body.removeChild(importmapScript);
          const supported = window.__jsenv_runtime_test_importmap__;
          delete window.__jsenv_runtime_test_importmap__;
          return supported;
        } catch (e) {
          document.body.removeChild(importmapScript);
          return false;
        }
      };

      const supportsDynamicImport = async () => {
        const moduleSource = asBase64Url(`export default 42`);

        try {
          await executeWithScriptModuleInjection(`window.__jsenv_runtime_test_dynamic_import__ = import(${JSON.stringify(moduleSource)})`);
          const namespace = await window.__jsenv_runtime_test_dynamic_import__;
          delete window.__jsenv_runtime_test_dynamic_import__;
          return namespace.default === 42;
        } catch (e) {
          return false;
        }
      };

      const supportsTopLevelAwait = async () => {
        try {
          await executeWithScriptModuleInjection(`window.__jsenv_runtime_test_top_level_await__ = await Promise.resolve(42)`);
          const supported = window.__jsenv_runtime_test_top_level_await__ === 42;
          delete window.__jsenv_runtime_test_top_level_await__;
          return supported;
        } catch (e) {
          return false;
        }
      };

      const supportsJsonImportAssertions = async () => {
        const jsonBase64Url = asBase64Url("42", "application/json");
        const moduleSource = asBase64Url(`import data from "${jsonBase64Url}" assert { type: "json" }
  export default data`);

        try {
          await executeWithScriptModuleInjection(`window.__jsenv_runtime_test_json_import_assertion__ = import(${JSON.stringify(moduleSource)})`);
          const namespace = await window.__jsenv_runtime_test_json_import_assertion__;
          const supported = namespace.default === 42;
          delete window.__jsenv_runtime_test_json_import_assertion__;
          return supported;
        } catch (e) {
          return false;
        }
      };

      const supportsCssImportAssertions = async () => {
        const cssBase64Url = asBase64Url("p { color: red; }", "text/css");
        const moduleSource = asBase64Url(`import css from "${cssBase64Url}" assert { type: "css" }
  export default css`);

        try {
          await executeWithScriptModuleInjection(`window.__jsenv_runtime_test_css_import_assertion__ = import(${JSON.stringify(moduleSource)})`);
          const namespace = await window.__jsenv_runtime_test_css_import_assertion__;
          return namespace.default instanceof CSSStyleSheet;
        } catch (e) {
          return false;
        }
      };

      const supportsNewStylesheet = () => {
        try {
          // eslint-disable-next-line no-new
          new CSSStyleSheet();
          return true;
        } catch (e) {
          return false;
        }
      };

      const scanBrowserRuntimeFeatures = async ({
        coverageHandledFromOutside = false,
        forceCompilation = false,
        forceSource = false
      } = {}) => {
        const jsenvCompileProfileUrl = "/__jsenv_compile_profile__";
        const {
          jsenvDirectoryRelativeUrl,
          inlineImportMapIntoHTML,
          availableCompileIds
        } = await fetchJson(jsenvCompileProfileUrl);
        const {
          name,
          version
        } = detectBrowser();
        const featuresReport = await detectSupportedFeatures({
          coverageHandledFromOutside,
          inlineImportMapIntoHTML
        });
        const runtimeReport = {
          env: {
            browser: true
          },
          name,
          version,
          featuresReport,
          forceSource,
          forceCompilation
        };
        const {
          compileProfile,
          compileId
        } = await fetchJson(jsenvCompileProfileUrl, {
          method: "POST",
          headers: {
            "content-type": "application/json"
          },
          body: JSON.stringify(runtimeReport)
        });
        return {
          jsenvDirectoryRelativeUrl,
          inlineImportMapIntoHTML,
          availableCompileIds,
          runtimeReport,
          compileProfile,
          compileId
        };
      };

      const detectSupportedFeatures = async ({
        coverageHandledFromOutside,
        inlineImportMapIntoHTML
      }) => {
        const featuresReport = {};
        featuresReport["import_http"] = true;
        featuresReport["coverage_js"] = coverageHandledFromOutside; // new CSSStyleSheet

        featuresReport["new_stylesheet"] = supportsNewStylesheet(); // importmap
        // start testing importmap support first and not in paralell
        // so that there is not module script loaded beore importmap is injected
        // it would log an error in chrome console and return undefined

        featuresReport.importmap = await supportsImportmap({
          // chrome supports inline but not remote importmap
          // https://github.com/WICG/import-maps/issues/235
          // at this stage we won't know if the html file will use
          // an importmap or not and if that importmap is inline or specified with an src
          // so we should test if browser support local and remote importmap.
          // But there exploring server can inline importmap by transforming html
          // and in that case we can test only the local importmap support
          // so we test importmap support and the remote one
          remote: !inlineImportMapIntoHTML
        }); // dynamic import

        featuresReport["import_dynamic"] = await supportsDynamicImport(); // top level await

        featuresReport["top_level_await"] = await supportsTopLevelAwait(); // import assertions

        featuresReport["import_assertion_type_json"] = await supportsJsonImportAssertions();
        featuresReport["import_assertion_type_css"] = await supportsCssImportAssertions();
        return featuresReport;
      };

      window.scanBrowserRuntimeFeatures = scanBrowserRuntimeFeatures;
      window.resolveReadyPromise();

    })
  };
}));

//# sourceMappingURL=compile_proxy.html__inline__20_cbed84a8.js.map</script>
  

</body></html>