{
  "version": 3,
  "sources": [
    "../../../src/coverFolder/coverFolder.js"
  ],
  "names": [
    "mergeCoverage",
    "coverages",
    "mergedCoverageMap",
    "reduce",
    "previous",
    "coverage",
    "merge",
    "toJSON",
    "metaPredicate",
    "cover",
    "test",
    "testProject",
    "server",
    "createClient",
    "compileURL",
    "root",
    "process",
    "cwd",
    "beforeAll",
    "beforeEach",
    "afterEach",
    "afterAll",
    "rootLocation",
    "path",
    "resolve",
    "getRequiredFileReport",
    "then",
    "forEachFileMatching",
    "relativeName",
    "meta",
    "Promise",
    "all",
    "client",
    "fileReport",
    "testFiles",
    "filter",
    "file",
    "map",
    "type",
    "sourceFiles",
    "files",
    "getFileByPath",
    "find",
    "testFile",
    "execute",
    "collectCoverage",
    "executeTest",
    "autoClose",
    "promise",
    "output",
    "Object",
    "keys",
    "forEach",
    "sourceFile",
    "untestedSourceFiles",
    "getEmptyCoverageFor",
    "compileFile",
    "outputAssets",
    "coverageAsset",
    "asset",
    "name",
    "JSON",
    "parse",
    "content",
    "s",
    "key",
    "missingCoverage",
    "createCoverageFromTestReport"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import { openChromiumClient } from \"../openChromiumClient/openChromiumClient.js\"\nimport path from \"path\"\nimport { createCoverageMap } from \"istanbul-lib-coverage\"\nimport { createRoot } from \"@dmail/project-structure\"\n\nconst mergeCoverage = (...coverages) => {\n  // https://github.com/istanbuljs/istanbuljs/blob/5405550c3868712b14fd8bfe0cbd6f2e7ac42279/packages/istanbul-lib-coverage/lib/coverage-map.js#L43\n  const mergedCoverageMap = coverages.reduce((previous, coverage) => {\n    return previous.merge(coverage)\n  }, createCoverageMap({}))\n\n  return mergedCoverageMap.toJSON()\n}\n\nconst metaPredicate = ({ cover, test }) => cover || test\n\nexport const testProject = ({\n  server,\n  createClient = () => openChromiumClient({ compileURL: server.compileURL }),\n  root = process.cwd(),\n  beforeAll = () => {},\n  beforeEach = () => {},\n  afterEach = () => {},\n  afterAll = () => {},\n}) => {\n  const rootLocation = path.resolve(process.cwd(), root)\n\n  const getRequiredFileReport = createRoot({ root: rootLocation }).then(\n    ({ forEachFileMatching }) => {\n      return forEachFileMatching(metaPredicate, ({ relativeName, meta }) => {\n        return { relativeName, meta }\n      })\n    },\n  )\n\n  return Promise.all([createClient(), getRequiredFileReport()]).then(([client, fileReport]) => {\n    const testFiles = fileReport.filter((file) => file.meta.test).map((file) => {\n      return {\n        path: `${rootLocation}/${file.relativeName}`,\n        type: \"test\",\n      }\n    })\n    const sourceFiles = fileReport.filter((file) => file.meta.cover).map((file) => {\n      return {\n        path: `${rootLocation}/${file.relativeName}`,\n        type: \"source\",\n      }\n    })\n    const files = [...testFiles, ...sourceFiles]\n\n    const getFileByPath = (path) => files.find((file) => file.path === path)\n\n    beforeAll({ files })\n    return Promise.all(\n      testFiles.map((testFile) => {\n        beforeEach({ file: testFile })\n\n        return client\n          .execute({\n            file: testFile.path,\n            collectCoverage: true,\n            executeTest: true,\n            autoClose: true,\n          })\n          .then(({ promise }) => promise)\n          .then(({ output, coverage }) => {\n            // test = null means file.test.js do not set a global.__test\n            // which happens if file.test.js does not use @dmail/test or is empty for instance\n            // coverage = null means file.test.js do not set a global.__coverage__\n            // which happens if file.test.js was not instrumented.\n            // this is not supposed to happen so we should throw ?\n            testFile.output = output\n            Object.keys(coverage).forEach((path) => {\n              const sourceFile = getFileByPath(path)\n              sourceFile.coverage = sourceFile.coverage\n                ? mergeCoverage(sourceFile.coverage, coverage[path])\n                : coverage[path]\n            })\n\n            afterEach({ file: testFile })\n          })\n      }),\n    )\n      .then(() => {\n        afterAll({ files })\n\n        const untestedSourceFiles = sourceFiles.filter((sourceFile) => {\n          return !sourceFile.coverage\n        })\n\n        const getEmptyCoverageFor = (file) => {\n          // we must compileFile to get the coverage object\n          // without evaluating the file source because it would increment coverage\n          // and also execute code that is not supposed to be run\n          return server.compileFile(file).then(({ outputAssets }) => {\n            const coverageAsset = outputAssets.find((asset) => asset.name === \"coverage\")\n            const coverage = JSON.parse(coverageAsset.content)\n            // https://github.com/gotwarlost/istanbul/blob/bc84c315271a5dd4d39bcefc5925cfb61a3d174a/lib/command/common/run-with-cover.js#L229\n            Object.keys(coverage.s).forEach(function(key) {\n              coverage.s[key] = 0\n            })\n            return coverage\n          })\n        }\n\n        return Promise.all(\n          untestedSourceFiles.map((sourceFile) => {\n            return getEmptyCoverageFor(sourceFile).then((missingCoverage) => {\n              sourceFile.coverage = missingCoverage\n            })\n          }),\n        )\n      })\n      .then(() => {\n        return files\n      })\n  })\n}\n\nexport const createCoverageFromTestReport = (files) => {\n  const coverage = {}\n\n  files.forEach((file) => {\n    if (file.coverage) {\n      coverage[file.coverage.path] = file.coverage\n    }\n  })\n\n  return coverage\n}\n"
  ]
}