{
  "version": 3,
  "sources": [
    "../../../src/createCompile/instrumenter-istanbul.js"
  ],
  "names": [
    "instrumenter",
    "inputRelativeLocation",
    "inputSource",
    "inputSourceMap",
    "inputAst",
    "coverageGlobalVariabeName",
    "istanbulInstrumenter",
    "istanbul",
    "Instrumenter",
    "coverageVariable",
    "esModules",
    "embedSource",
    "includes",
    "codeGenerationOptions",
    "sourceMap",
    "sourceContent",
    "sourceMapWithCode",
    "file",
    "outputSource",
    "instrumentASTSync",
    "instrumentSync",
    "outputSourceMap",
    "lastSourceMap",
    "inputCodeSourceMapConsumer",
    "SourceMapConsumer",
    "intrumentedCodeSourceMapConsumer",
    "generator",
    "SourceMapGenerator",
    "fromSourceMap",
    "applySourceMap",
    "JSON",
    "parse",
    "toString"
  ],
  "mappings": ";;;;;;;AAEA;;AAEA;;;;AAJA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEO,IAAMA,YAAY,GAAG,SAAfA,YAAe,OAMtB;AAAA,MALJC,qBAKI,QALJA,qBAKI;AAAA,MAJJC,WAII,QAJJA,WAII;AAAA,MAHJC,cAGI,QAHJA,cAGI;AAAA,MAFJC,QAEI,QAFJA,QAEI;AAAA,mCADJC,yBACI;AAAA,MADJA,yBACI,sCADwB,cACxB;AACJ;AACA,MAAMC,oBAAoB,GAAG,IAAIC,kBAASC,YAAb,CAA0B;AACrDC,IAAAA,gBAAgB,EAAEJ,yBADmC;AAErDK,IAAAA,SAAS,EAAE,IAF0C;AAGrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,IAAAA,WAAW,EAAEV,qBAAqB,CAACW,QAAtB,CAA+B,WAA/B,CAXwC;AAYrDC,IAAAA,qBAAqB,EAAE;AACrB;AACA;AACAC,MAAAA,SAAS,EAAEb,qBAHU;AAIrBc,MAAAA,aAAa,EAAEb,WAJM;AAKrBc,MAAAA,iBAAiB,EAAE,IALE;AAMrBC,MAAAA,IAAI,EAAEhB;AANe;AAZ8B,GAA1B,CAA7B;AAsBA,MAAMiB,YAAY,GAAGd,QAAQ,GACzBE,oBAAoB,CAACa,iBAArB,CAAuCf,QAAvC,EAAiDH,qBAAjD,EAAwEC,WAAxE,CADyB,GAEzBI,oBAAoB,CAACc,cAArB,CAAoClB,WAApC,EAAiDD,qBAAjD,CAFJ;AAGA,MAAMoB,eAAe,GAAGf,oBAAoB,CAACgB,aAArB,EAAxB;;AAEA,MAAInB,cAAJ,EAAoB;AAClB;AACA,QAAMoB,0BAA0B,GAAG,IAAIC,4BAAJ,CAAsBrB,cAAtB,CAAnC;AACA,QAAMsB,gCAAgC,GAAG,IAAID,4BAAJ,CAAsBH,eAAtB,CAAzC;;AACA,QAAMK,SAAS,GAAGC,8BAAmBC,aAAnB,CAAiCH,gCAAjC,CAAlB;;AACAC,IAAAA,SAAS,CAACG,cAAV,CAAyBN,0BAAzB;AAEA,WAAO;AACLlB,MAAAA,yBAAyB,EAAzBA,yBADK;AAELa,MAAAA,YAAY,EAAZA,YAFK;AAGLG,MAAAA,eAAe,EAAES,IAAI,CAACC,KAAL,CAAWL,SAAS,CAACM,QAAV,EAAX;AAHZ,KAAP;AAKD;;AAED,SAAO;AACL3B,IAAAA,yBAAyB,EAAzBA,yBADK;AAELa,IAAAA,YAAY,EAAZA,YAFK;AAGLG,IAAAA,eAAe,EAAfA;AAHK,GAAP;AAKD,CAtDM",
  "sourcesContent": [
    "// why not https://github.com/istanbuljs/babel-plugin-istanbul ?\n// https://github.com/guybedford/systemjs-istanbul/blob/master/index.js\nimport istanbul from \"istanbul\"\n// import remapIstanbul from \"remap-istanbul/lib/remap\" // \"remap-istanbul\": \"0.8.4\",\nimport { SourceMapConsumer, SourceMapGenerator } from \"source-map\"\n\n// const getCoverage = ({ globalName }) => {\n//   return global[globalName]\n// }\n\n// // remap coverage will be needed later so that our coverage object\n// // is remapped using sourcemaps\n// const remapCoverage = (coverage) => {\n//   return remapIstanbul(coverage)\n// }\n\n// const getCoverageGlobalVariableName = () => {\n//   for (const key in global) {\n//     if (key.match(/\\$\\$cov_\\d+\\$\\$/)) {\n//       return key\n//     }\n//   }\n//   return null\n// }\n\nexport const instrumenter = ({\n  inputRelativeLocation,\n  inputSource,\n  inputSourceMap,\n  inputAst,\n  coverageGlobalVariabeName = \"__coverage__\",\n}) => {\n  // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html\n  const istanbulInstrumenter = new istanbul.Instrumenter({\n    coverageVariable: coverageGlobalVariabeName,\n    esModules: true,\n    // tod: put this to true if the instrumented module is anonymous\n    // a way to know if the module is register anonymously doing System.module is to check if it's adress looks like\n    // '<Anonymous Module ' + ++anonCnt + '>';\n    // https://github.com/ModuleLoader/es6-module-loader/issues/489\n    // but if the anonymous module provide an adress you're fucked\n    // also when a normal module use <Anonymous Module 1> name\n    // in both cases we would consider it as anonymous by mistake\n    // for now we will enable embedSource if the load.address includes anonymous somewhere\n    embedSource: inputRelativeLocation.includes(\"anonymous\"),\n    codeGenerationOptions: {\n      // il faut passer le fichier d'origine, sauf que ce fichier n'est pas dispo sur le fs puisque transpiled\n      // il le sera ptet par la suite\n      sourceMap: inputRelativeLocation,\n      sourceContent: inputSource,\n      sourceMapWithCode: true,\n      file: inputRelativeLocation,\n    },\n  })\n\n  const outputSource = inputAst\n    ? istanbulInstrumenter.instrumentASTSync(inputAst, inputRelativeLocation, inputSource)\n    : istanbulInstrumenter.instrumentSync(inputSource, inputRelativeLocation)\n  const outputSourceMap = istanbulInstrumenter.lastSourceMap()\n\n  if (inputSourceMap) {\n    // https://github.com/karma-runner/karma-coverage/pull/146/files\n    const inputCodeSourceMapConsumer = new SourceMapConsumer(inputSourceMap)\n    const intrumentedCodeSourceMapConsumer = new SourceMapConsumer(outputSourceMap)\n    const generator = SourceMapGenerator.fromSourceMap(intrumentedCodeSourceMapConsumer)\n    generator.applySourceMap(inputCodeSourceMapConsumer)\n\n    return {\n      coverageGlobalVariabeName,\n      outputSource,\n      outputSourceMap: JSON.parse(generator.toString()),\n    }\n  }\n\n  return {\n    coverageGlobalVariabeName,\n    outputSource,\n    outputSourceMap,\n  }\n}\n"
  ]
}