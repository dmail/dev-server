{"version":3,"sources":["../../../src/createCompile/instrumenter.js"],"names":["getCoverage","globalName","global","remapCoverage","coverage","getCoverageGlobalVariableName","key","match","instrumenter","inputRelativeLocation","inputSource","inputSourceMap","inputAst","coverageGlobalVariabeName","istanbulInstrumenter","Instrumenter","coverageVariable","esModules","embedSource","includes","codeGenerationOptions","sourceMap","sourceContent","sourceMapWithCode","file","outputSource","instrumentASTSync","instrumentSync","outputSourceMap","lastSourceMap","inputCodeSourceMapConsumer","intrumentedCodeSourceMapConsumer","generator","fromSourceMap","applySourceMap","JSON","parse","toString"],"mappings":";;;;;;;AAEA;;;;AACA;;;;AACA;;;;AAEO,IAAMA,oCAAc,SAAdA,WAAc,OAAoB;AAAA,MAAjBC,UAAiB,QAAjBA,UAAiB;;AAC7C,SAAOC,OAAOD,UAAP,CAAP;AACD,CAFM;;AAIP;AACA;AAXA;AACA;AAWO,IAAME,wCAAgB,SAAhBA,aAAgB,CAACC,QAAD,EAAc;AACzC,SAAO,wBAAcA,QAAd,CAAP;AACD,CAFM;;AAIA,IAAMC,wEAAgC,SAAhCA,6BAAgC,GAAM;AACjD,OAAK,IAAMC,GAAX,IAAkBJ,MAAlB,EAA0B;AACxB,QAAII,IAAIC,KAAJ,CAAU,iBAAV,CAAJ,EAAkC;AAChC,aAAOD,GAAP;AACD;AACF;AACD,SAAO,IAAP;AACD,CAPM;;AASA,IAAME,sCAAe,SAAfA,YAAe,QAMtB;AAAA,MALJC,qBAKI,SALJA,qBAKI;AAAA,MAJJC,WAII,SAJJA,WAII;AAAA,MAHJC,cAGI,SAHJA,cAGI;AAAA,MAFJC,QAEI,SAFJA,QAEI;AAAA,oCADJC,yBACI;AAAA,MADJA,yBACI,yCADwB,cACxB;;AACJ;AACA,MAAMC,uBAAuB,IAAI,sBAASC,YAAb,CAA0B;AACrDC,sBAAkBH,yBADmC;AAErDI,eAAW,IAF0C;AAGrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,iBAAaT,sBAAsBU,QAAtB,CAA+B,WAA/B,CAXwC;AAYrDC,2BAAuB;AACrB;AACA;AACAC,iBAAWZ,qBAHU;AAIrBa,qBAAeZ,WAJM;AAKrBa,yBAAmB,IALE;AAMrBC,YAAMf;AANe;AAZ8B,GAA1B,CAA7B;;AAsBA,MAAMgB,eAAeb,WACjBE,qBAAqBY,iBAArB,CAAuCd,QAAvC,EAAiDH,qBAAjD,EAAwEC,WAAxE,CADiB,GAEjBI,qBAAqBa,cAArB,CAAoCjB,WAApC,EAAiDD,qBAAjD,CAFJ;AAGA,MAAMmB,kBAAkBd,qBAAqBe,aAArB,EAAxB;;AAEA,MAAIlB,cAAJ,EAAoB;AAClB;AACA,QAAMmB,6BAA6B,iCAAsBnB,cAAtB,CAAnC;AACA,QAAMoB,mCAAmC,iCAAsBH,eAAtB,CAAzC;AACA,QAAMI,YAAY,8BAAmBC,aAAnB,CAAiCF,gCAAjC,CAAlB;AACAC,cAAUE,cAAV,CAAyBJ,0BAAzB;;AAEA,WAAO;AACLjB,0DADK;AAELY,gCAFK;AAGLG,uBAAiBO,KAAKC,KAAL,CAAWJ,UAAUK,QAAV,EAAX;AAHZ,KAAP;AAKD;;AAED,SAAO;AACLxB,wDADK;AAELY,8BAFK;AAGLG;AAHK,GAAP;AAKD,CAtDM","file":"instrumenter.js","sourcesContent":["// why not https://github.com/istanbuljs/babel-plugin-istanbul ?\n// https://github.com/guybedford/systemjs-istanbul/blob/master/index.js\nimport istanbul from \"istanbul\"\nimport remapIstanbul from \"remap-istanbul/lib/remap\"\nimport { SourceMapConsumer, SourceMapGenerator } from \"source-map\"\n\nexport const getCoverage = ({ globalName }) => {\n  return global[globalName]\n}\n\n// remap coverage will be needed later so that our coverage object\n// is remapped using sourcemaps\nexport const remapCoverage = (coverage) => {\n  return remapIstanbul(coverage)\n}\n\nexport const getCoverageGlobalVariableName = () => {\n  for (const key in global) {\n    if (key.match(/\\$\\$cov_\\d+\\$\\$/)) {\n      return key\n    }\n  }\n  return null\n}\n\nexport const instrumenter = ({\n  inputRelativeLocation,\n  inputSource,\n  inputSourceMap,\n  inputAst,\n  coverageGlobalVariabeName = \"__coverage__\",\n}) => {\n  // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html\n  const istanbulInstrumenter = new istanbul.Instrumenter({\n    coverageVariable: coverageGlobalVariabeName,\n    esModules: true,\n    // tod: put this to true if the instrumented module is anonymous\n    // a way to know if the module is register anonymously doing System.module is to check if it's adress looks like\n    // '<Anonymous Module ' + ++anonCnt + '>';\n    // https://github.com/ModuleLoader/es6-module-loader/issues/489\n    // but if the anonymous module provide an adress you're fucked\n    // also when a normal module use <Anonymous Module 1> name\n    // in both cases we would consider it as anonymous by mistake\n    // for now we will enable embedSource if the load.address includes anonymous somewhere\n    embedSource: inputRelativeLocation.includes(\"anonymous\"),\n    codeGenerationOptions: {\n      // il faut passer le fichier d'origine, sauf que ce fichier n'est pas dispo sur le fs puisque transpiled\n      // il le sera ptet par la suite\n      sourceMap: inputRelativeLocation,\n      sourceContent: inputSource,\n      sourceMapWithCode: true,\n      file: inputRelativeLocation,\n    },\n  })\n\n  const outputSource = inputAst\n    ? istanbulInstrumenter.instrumentASTSync(inputAst, inputRelativeLocation, inputSource)\n    : istanbulInstrumenter.instrumentSync(inputSource, inputRelativeLocation)\n  const outputSourceMap = istanbulInstrumenter.lastSourceMap()\n\n  if (inputSourceMap) {\n    // https://github.com/karma-runner/karma-coverage/pull/146/files\n    const inputCodeSourceMapConsumer = new SourceMapConsumer(inputSourceMap)\n    const intrumentedCodeSourceMapConsumer = new SourceMapConsumer(outputSourceMap)\n    const generator = SourceMapGenerator.fromSourceMap(intrumentedCodeSourceMapConsumer)\n    generator.applySourceMap(inputCodeSourceMapConsumer)\n\n    return {\n      coverageGlobalVariabeName,\n      outputSource,\n      outputSourceMap: JSON.parse(generator.toString()),\n    }\n  }\n\n  return {\n    coverageGlobalVariabeName,\n    outputSource,\n    outputSourceMap,\n  }\n}\n"]}