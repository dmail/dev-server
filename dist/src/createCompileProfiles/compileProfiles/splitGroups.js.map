{
  "version": 3,
  "sources": [
    "../../../../src/createCompileProfiles/compileProfiles/splitGroups.js"
  ],
  "names": [
    "getChunkSizes",
    "array",
    "size",
    "i",
    "chunkSize",
    "Math",
    "ceil",
    "length",
    "chunkSizes",
    "push",
    "splitGroups",
    "groups",
    "getScoreForGroup",
    "count",
    "reverse",
    "finalGroups",
    "sortedGroups",
    "sort",
    "a",
    "b",
    "remainingGroups",
    "groupsToMerge",
    "slice",
    "mergedGroup",
    "Object",
    "keys",
    "compatMap"
  ],
  "mappings": ";;;;;;;AAAA;;AAEA,MAAMA,aAAa,GAAG,CAACC,KAAD,EAAQC,IAAR,KAAiB;AACrC,MAAIC,CAAC,GAAG,CAAR;AACA,QAAMC,SAAS,GAAGC,IAAI,CAACC,IAAL,CAAUL,KAAK,CAACM,MAAN,GAAeL,IAAzB,CAAlB;AACA,QAAMM,UAAU,GAAG,EAAnB;;AACA,SAAOL,CAAC,GAAGF,KAAK,CAACM,MAAjB,EAAyB;AACvB,QAAIJ,CAAC,GAAGC,SAAJ,GAAgBH,KAAK,CAACM,MAA1B,EAAkC;AAChC,YAAMH,SAAS,GAAGH,KAAK,CAACM,MAAN,GAAeJ,CAAjC;AACAA,MAAAA,CAAC,IAAIC,SAAL;AACAI,MAAAA,UAAU,CAACC,IAAX,CAAgBL,SAAhB;AACD,KAJD,MAIO;AACLD,MAAAA,CAAC,IAAIC,SAAL;AACAI,MAAAA,UAAU,CAACC,IAAX,CAAgBL,SAAhB;AACD;AACF;;AACD,SAAOI,UAAP;AACD,CAfD;;AAiBO,MAAME,WAAW,GAAG,CAACC,MAAD,EAASC,gBAAT,EAA2BC,KAAK,GAAG,CAAnC,KAAyC;AAClE,MAAIV,CAAC,GAAG,CAAR;AACA,QAAMK,UAAU,GAAGR,aAAa,CAACW,MAAD,EAASE,KAAT,CAAb,CAA6BC,OAA7B,EAAnB;AACA,QAAMC,WAAW,GAAG,EAApB;AACA,QAAMC,YAAY,GAAGL,MAAM,CAACM,IAAP,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAUP,gBAAgB,CAACO,CAAD,CAAhB,GAAsBP,gBAAgB,CAACM,CAAD,CAA5D,CAArB;AACA,MAAIE,eAAe,GAAGJ,YAAtB;;AAEA,SAAOb,CAAC,GAAGK,UAAU,CAACD,MAAtB,EAA8B;AAC5B,UAAMc,aAAa,GAAGD,eAAe,CAACE,KAAhB,CAAsB,CAAtB,EAAyBd,UAAU,CAACL,CAAD,CAAnC,CAAtB;AACAiB,IAAAA,eAAe,GAAGA,eAAe,CAACE,KAAhB,CAAsBd,UAAU,CAACL,CAAD,CAAhC,CAAlB;AACA,UAAMoB,WAAW,GAAG,kCAAc,GAAGF,aAAjB,CAApB;;AACA,QAAIG,MAAM,CAACC,IAAP,CAAYF,WAAW,CAACG,SAAxB,EAAmCnB,MAAvC,EAA+C;AAC7CQ,MAAAA,WAAW,CAACN,IAAZ,CAAiBc,WAAjB;AACD;;AACDpB,IAAAA,CAAC;AACF;;AAED,SAAOY,WAAP;AACD,CAlBM",
  "sourcesContent": [
    "import { composeGroups } from \"./composeGroups.js\"\n\nconst getChunkSizes = (array, size) => {\n  let i = 0\n  const chunkSize = Math.ceil(array.length / size)\n  const chunkSizes = []\n  while (i < array.length) {\n    if (i + chunkSize > array.length) {\n      const chunkSize = array.length - i\n      i += chunkSize\n      chunkSizes.push(chunkSize)\n    } else {\n      i += chunkSize\n      chunkSizes.push(chunkSize)\n    }\n  }\n  return chunkSizes\n}\n\nexport const splitGroups = (groups, getScoreForGroup, count = 4) => {\n  let i = 0\n  const chunkSizes = getChunkSizes(groups, count).reverse()\n  const finalGroups = []\n  const sortedGroups = groups.sort((a, b) => getScoreForGroup(b) - getScoreForGroup(a))\n  let remainingGroups = sortedGroups\n\n  while (i < chunkSizes.length) {\n    const groupsToMerge = remainingGroups.slice(0, chunkSizes[i])\n    remainingGroups = remainingGroups.slice(chunkSizes[i])\n    const mergedGroup = composeGroups(...groupsToMerge)\n    if (Object.keys(mergedGroup.compatMap).length) {\n      finalGroups.push(mergedGroup)\n    }\n    i++\n  }\n\n  return finalGroups\n}\n"
  ]
}