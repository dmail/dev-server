{"version":3,"sources":["../../../src/openCompileServer/instrumenter.js"],"names":["getCoverage","globalName","global","remapCoverage","coverage","getCoverageGlobalVariableName","key","match","instrumenter","code","map","ast","rest","coverageGlobalVariabeName","inputRelativeLocation","istanbulInstrumenter","Instrumenter","coverageVariable","esModules","embedSource","includes","codeGenerationOptions","sourceMap","sourceContent","sourceMapWithCode","file","outputCode","instrumentASTSync","instrumentSync","outputCodeSourceMap","lastSourceMap","inputCodeSourceMapConsumer","intrumentedCodeSourceMapConsumer","generator","fromSourceMap","applySourceMap","JSON","parse","toString"],"mappings":";;;;;;;;;AAEA;;;;AACA;;;;AACA;;;;6NAJA;AACA;;;AAKO,IAAMA,oCAAc,SAAdA,WAAc,OAAoB;AAAA,MAAjBC,UAAiB,QAAjBA,UAAiB;;AAC7C,SAAOC,OAAOD,UAAP,CAAP;AACD,CAFM;;AAIP;AACA;AACO,IAAME,wCAAgB,SAAhBA,aAAgB,CAACC,QAAD,EAAc;AACzC,SAAO,wBAAcA,QAAd,CAAP;AACD,CAFM;;AAIA,IAAMC,wEAAgC,SAAhCA,6BAAgC,GAAM;AACjD,OAAK,IAAMC,GAAX,IAAkBJ,MAAlB,EAA0B;AACxB,QAAII,IAAIC,KAAJ,CAAU,iBAAV,CAAJ,EAAkC;AAChC,aAAOD,GAAP;AACD;AACF;AACD,SAAO,IAAP;AACD,CAPM;;AASA,IAAME,eAAe,SAAfA,YAAe,sBAIvB;AAAA,MAHDC,IAGC,SAHDA,IAGC;AAAA,MAHKC,GAGL,SAHKA,GAGL;AAAA,MAHUC,GAGV,SAHUA,GAGV;AAAA,MAHkBC,IAGlB;;AAAA,oCAFDC,yBAEC;AAAA,MAFDA,yBAEC,yCAF2B,cAE3B;AAAA,MADDC,qBACC,SADDA,qBACC;;AACH;AACA,MAAMC,uBAAuB,IAAI,sBAASC,YAAb,CAA0B;AACrDC,sBAAkBJ,yBADmC;AAErDK,eAAW,IAF0C;AAGrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,iBAAaL,sBAAsBM,QAAtB,CAA+B,WAA/B,CAXwC;AAYrDC,2BAAuB;AACrB;AACA;AACAC,iBAAWR,qBAHU;AAIrBS,qBAAed,IAJM;AAKrBe,yBAAmB,IALE;AAMrBC,YAAMX;AANe;AAZ8B,GAA1B,CAA7B;;AAsBA,MAAMY,aAAaf,MACfI,qBAAqBY,iBAArB,CAAuChB,GAAvC,EAA4CG,qBAA5C,EAAmEL,IAAnE,CADe,GAEfM,qBAAqBa,cAArB,CAAoCnB,IAApC,EAA0CK,qBAA1C,CAFJ;AAGA,MAAMe,sBAAsBd,qBAAqBe,aAArB,EAA5B;;AAEA,MAAIpB,GAAJ,EAAS;AACP;AACA,QAAMqB,6BAA6B,iCAAsBrB,GAAtB,CAAnC;AACA,QAAMsB,mCAAmC,iCAAsBH,mBAAtB,CAAzC;AACA,QAAMI,YAAY,8BAAmBC,aAAnB,CAAiCF,gCAAjC,CAAlB;AACAC,cAAUE,cAAV,CAAyBJ,0BAAzB;;AAEA;AACEtB,YAAMiB,UADR;AAEEhB,WAAK0B,KAAKC,KAAL,CAAWJ,UAAUK,QAAV,EAAX;AAFP,OAGK1B,IAHL;AAKD;;AAED;AACEH,UAAMiB,UADR;AAEEhB,SAAKmB;AAFP,KAGKjB,IAHL;AAKD,CApDM","file":"instrumenter.js","sourcesContent":["// why not https://github.com/istanbuljs/babel-plugin-istanbul ?\n// https://github.com/guybedford/systemjs-istanbul/blob/master/index.js\nimport istanbul from \"istanbul\"\nimport remapIstanbul from \"remap-istanbul/lib/remap\"\nimport { SourceMapConsumer, SourceMapGenerator } from \"source-map\"\n\nexport const getCoverage = ({ globalName }) => {\n  return global[globalName]\n}\n\n// remap coverage will be needed later so that our coverage object\n// is remapped using sourcemaps\nexport const remapCoverage = (coverage) => {\n  return remapIstanbul(coverage)\n}\n\nexport const getCoverageGlobalVariableName = () => {\n  for (const key in global) {\n    if (key.match(/\\$\\$cov_\\d+\\$\\$/)) {\n      return key\n    }\n  }\n  return null\n}\n\nexport const instrumenter = (\n  { code, map, ast, ...rest },\n  { coverageGlobalVariabeName = \"__coverage__\" },\n  { inputRelativeLocation },\n) => {\n  // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html\n  const istanbulInstrumenter = new istanbul.Instrumenter({\n    coverageVariable: coverageGlobalVariabeName,\n    esModules: true,\n    // tod: put this to true if the instrumented module is anonymous\n    // a way to know if the module is register anonymously doing System.module is to check if it's adress looks like\n    // '<Anonymous Module ' + ++anonCnt + '>';\n    // https://github.com/ModuleLoader/es6-module-loader/issues/489\n    // but if the anonymous module provide an adress you're fucked\n    // also when a normal module use <Anonymous Module 1> name\n    // in both cases we would consider it as anonymous by mistake\n    // for now we will enable embedSource if the load.address includes anonymous somewhere\n    embedSource: inputRelativeLocation.includes(\"anonymous\"),\n    codeGenerationOptions: {\n      // il faut passer le fichier d'origine, sauf que ce fichier n'est pas dispo sur le fs puisque transpiled\n      // il le sera ptet par la suite\n      sourceMap: inputRelativeLocation,\n      sourceContent: code,\n      sourceMapWithCode: true,\n      file: inputRelativeLocation,\n    },\n  })\n\n  const outputCode = ast\n    ? istanbulInstrumenter.instrumentASTSync(ast, inputRelativeLocation, code)\n    : istanbulInstrumenter.instrumentSync(code, inputRelativeLocation)\n  const outputCodeSourceMap = istanbulInstrumenter.lastSourceMap()\n\n  if (map) {\n    // https://github.com/karma-runner/karma-coverage/pull/146/files\n    const inputCodeSourceMapConsumer = new SourceMapConsumer(map)\n    const intrumentedCodeSourceMapConsumer = new SourceMapConsumer(outputCodeSourceMap)\n    const generator = SourceMapGenerator.fromSourceMap(intrumentedCodeSourceMapConsumer)\n    generator.applySourceMap(inputCodeSourceMapConsumer)\n\n    return {\n      code: outputCode,\n      map: JSON.parse(generator.toString()),\n      ...rest,\n    }\n  }\n\n  return {\n    code: outputCode,\n    map: outputCodeSourceMap,\n    ...rest,\n  }\n}\n"]}