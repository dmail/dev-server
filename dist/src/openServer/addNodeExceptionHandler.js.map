{
  "version": 3,
  "sources": [
    "../../../src/openServer/addNodeExceptionHandler.js"
  ],
  "names": [
    "exceptionEmitter",
    "resolve",
    "reject",
    "recoverManualPromise",
    "Promise",
    "res",
    "rej",
    "visitor",
    "param",
    "recoverListenerPromise",
    "value",
    "race",
    "createAddExceptionHandler",
    "install",
    "exceptionSignal",
    "emitter",
    "recursed",
    "emitExecution",
    "args",
    "console",
    "error",
    "installer",
    "isEmitting",
    "getEmitExecution",
    "emit",
    "disableWhileCalling",
    "triggerException",
    "exception",
    "then",
    "recovered",
    "otherException",
    "recoverWhen",
    "match",
    "getArguments",
    "listen",
    "addNodeExceptionHandler",
    "onError",
    "onUnhandledRejection",
    "promise",
    "origin",
    "onRejectionHandled",
    "process",
    "on",
    "removeListener"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import { createSignal, someAsyncListenerResolvesWith } from \"@dmail/signal\"\n\nconst exceptionEmitter = () => {\n  let resolve\n  let reject\n  const recoverManualPromise = new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  const visitor = (param) => {\n    const recoverListenerPromise = someAsyncListenerResolvesWith((value) => value === true)(param)\n    return Promise.race([recoverManualPromise, recoverListenerPromise])\n  }\n\n  return { visitor, resolve, reject }\n}\n\nconst createAddExceptionHandler = ({ install }) => {\n  const exceptionSignal = createSignal({\n    emitter: exceptionEmitter,\n    recursed: ({ emitExecution, args }) => {\n      console.error(`${args[0].value} error occured while handling ${emitExecution.args[0]}`)\n      emitExecution.resolve(false)\n    },\n    installer: ({ isEmitting, getEmitExecution, emit, disableWhileCalling }) => {\n      const triggerException = (exception) => {\n        emit(exception).then(\n          (recovered) => {\n            if (recovered) {\n              return\n            }\n            // removeAllWhileCalling prevent catching of the next throw\n            // else the following would create an infinite loop\n            // process.on('uncaughtException', function() {\n            //     setTimeout(function() {\n            //         throw 'yo';\n            //     });\n            // });\n            disableWhileCalling(() => {\n              throw exception.value // this mess up the stack trace :'(\n            })\n          },\n          (otherException) => {\n            console.error(`${otherException} internal error occured while handling ${exception}`)\n            disableWhileCalling(() => {\n              throw exception.value\n            })\n          },\n        )\n      }\n\n      const recoverWhen = (match) => {\n        if (isEmitting()) {\n          const emitExecution = getEmitExecution()\n          if (match(...emitExecution.getArguments())) {\n            emitExecution.resolve(true)\n          }\n        }\n      }\n\n      return install({\n        triggerException,\n        recoverWhen,\n      })\n    },\n  })\n\n  return exceptionSignal.listen\n}\n\nexport const addNodeExceptionHandler = createAddExceptionHandler({\n  install: ({ triggerException, recoverWhen }) => {\n    const onError = (error) => {\n      triggerException({\n        value: error,\n      })\n    }\n\n    const onUnhandledRejection = (value, promise) => {\n      triggerException({\n        value,\n        origin: promise,\n      })\n    }\n\n    const onRejectionHandled = (promise) => {\n      recoverWhen(({ origin }) => origin === promise)\n    }\n\n    process.on(\"unhandledRejection\", onUnhandledRejection)\n    process.on(\"rejectionHandled\", onRejectionHandled)\n    process.on(\"uncaughtException\", onError)\n\n    return () => {\n      process.removeListener(\"unhandledRejection\", onUnhandledRejection)\n      process.removeListener(\"rejectionHandled\", onRejectionHandled)\n      process.removeListener(\"uncaughtException\", onError)\n    }\n  },\n})\n"
  ]
}