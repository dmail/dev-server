{
  "version": 3,
  "sources": [
    "../../../src/openServer/addNodeExceptionHandler.js"
  ],
  "names": [
    "exceptionEmitter",
    "resolve",
    "reject",
    "recoverManualPromise",
    "Promise",
    "res",
    "rej",
    "visitor",
    "param",
    "recoverListenerPromise",
    "value",
    "race",
    "createAddExceptionHandler",
    "install",
    "exceptionSignal",
    "emitter",
    "recursed",
    "emitExecution",
    "args",
    "console",
    "error",
    "installer",
    "isEmitting",
    "getEmitExecution",
    "emit",
    "disableWhileCalling",
    "triggerException",
    "exception",
    "then",
    "recovered",
    "otherException",
    "recoverWhen",
    "match",
    "getArguments",
    "listen",
    "addNodeExceptionHandler",
    "onError",
    "onUnhandledRejection",
    "promise",
    "origin",
    "onRejectionHandled",
    "process",
    "on",
    "removeListener"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import { createSignal, someAsyncListenerResolvesWith } from \"@dmail/signal\"\n\nconst exceptionEmitter = () => {\n  let resolve\n  let reject\n  const recoverManualPromise = new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  const visitor = (param) => {\n    const recoverListenerPromise = someAsyncListenerResolvesWith((value) => value === true)(param)\n    return Promise.race([recoverManualPromise, recoverListenerPromise])\n  }\n\n  return { visitor, resolve, reject }\n}\n\nconst createAddExceptionHandler = ({ install }) => {\n  const exceptionSignal = createSignal({\n    emitter: exceptionEmitter,\n    recursed: ({ emitExecution, args }) => {\n      console.error(`${args[0].value} error occured while handling ${emitExecution.args[0]}`)\n      emitExecution.resolve(false)\n    },\n    installer: ({ isEmitting, getEmitExecution, emit, disableWhileCalling }) => {\n      const triggerException = (exception) => {\n        emit(exception).then(\n          (recovered) => {\n            if (recovered) {\n              return\n            }\n            // removeAllWhileCalling prevent catching of the next throw\n            // else the following would create an infinite loop\n            // process.on('uncaughtException', function() {\n            //     setTimeout(function() {\n            //         throw 'yo';\n            //     });\n            // });\n            disableWhileCalling(() => {\n              throw exception.value // this mess up the stack trace :'(\n            })\n          },\n          (otherException) => {\n            console.error(`${otherException} internal error occured while handling ${exception}`)\n            disableWhileCalling(() => {\n              throw exception.value\n            })\n          },\n        )\n      }\n\n      const recoverWhen = (match) => {\n        if (isEmitting()) {\n          const emitExecution = getEmitExecution()\n          if (match(...emitExecution.getArguments())) {\n            emitExecution.resolve(true)\n          }\n        }\n      }\n\n      return install({\n        triggerException,\n        recoverWhen,\n      })\n    },\n  })\n\n  return exceptionSignal.listen\n}\n\nexport const addNodeExceptionHandler = createAddExceptionHandler({\n  install: ({ triggerException, recoverWhen }) => {\n    const onError = (error) => {\n      triggerException({\n        value: error,\n      })\n    }\n\n    const onUnhandledRejection = (value, promise) => {\n      triggerException({\n        value,\n        origin: promise,\n      })\n    }\n\n    const onRejectionHandled = (promise) => {\n      recoverWhen(({ origin }) => origin === promise)\n    }\n\n    process.on(\"unhandledRejection\", onUnhandledRejection)\n    process.on(\"rejectionHandled\", onRejectionHandled)\n    process.on(\"uncaughtException\", onError)\n\n    return () => {\n      process.removeListener(\"unhandledRejection\", onUnhandledRejection)\n      process.removeListener(\"rejectionHandled\", onRejectionHandled)\n      process.removeListener(\"uncaughtException\", onError)\n    }\n  },\n})\n"
  ]
}