{"version":3,"sources":["../../../src/openServer/createHeaders.js"],"names":["normalizeName","headerName","String","test","TypeError","toLowerCase","normalizeValue","headerValue","convertToClientName","parseHeaders","headerString","headers","pairs","pair","index","i","j","key","value","split","length","indexOf","slice","createHeaders","guard","map","Map","checkImmutability","has","name","get","getAll","set","append","values","push","combine","remove","entries","keys","forEach","fn","bind","Array","from","headerValues","call","toString","join","toJSON","populate","Symbol","iterator","Object","freeze"],"mappings":"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","file":"createHeaders.js","sourcesContent":["/*\nhttps://developer.mozilla.org/en-US/docs/Web/API/Headers\nhttps://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n*/\n\nconst normalizeName = (headerName) => {\n  headerName = String(headerName)\n  if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(headerName)) {\n    throw new TypeError(\"Invalid character in header field name\")\n  }\n\n  return headerName.toLowerCase()\n}\n\nconst normalizeValue = (headerValue) => {\n  return String(headerValue)\n}\n\nconst convertToClientName = (headerName) => {\n  return headerName\n}\n\n// https://gist.github.com/mmazer/5404301\nconst parseHeaders = (headerString) => {\n  var headers = {}\n  var pairs\n  var pair\n  var index\n  var i\n  var j\n  var key\n  var value\n\n  if (headerString) {\n    pairs = headerString.split(\"\\r\\n\")\n    i = 0\n    j = pairs.length\n    for (; i < j; i++) {\n      pair = pairs[i]\n      index = pair.indexOf(\": \")\n      if (index > 0) {\n        key = pair.slice(0, index)\n        value = pair.slice(index + 2)\n        headers[key] = value\n      }\n    }\n  }\n\n  return headers\n}\n\nexport const createHeaders = (headers) => {\n  const guard = \"none\"\n  const map = new Map()\n\n  const checkImmutability = () => {\n    if (guard === \"immutable\") {\n      throw new TypeError(\"headers are immutable\")\n    }\n  }\n\n  const has = (name) => map.has(normalizeName(name))\n\n  const get = (name) => {\n    name = normalizeName(name)\n    return map.has(name) ? map.get(name)[0] : null\n  }\n\n  const getAll = (name) => {\n    name = normalizeName(name)\n    return map.has(name) ? map.get(name) : []\n  }\n\n  const set = (name, value) => {\n    checkImmutability()\n\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    map.set(name, [value])\n  }\n\n  const append = (name, value) => {\n    checkImmutability()\n\n    name = normalizeName(name)\n    value = normalizeValue(value)\n\n    let values\n\n    if (map.has(name)) {\n      values = map.get(name)\n    } else {\n      values = []\n    }\n\n    values.push(value)\n    map.set(name, values)\n  }\n\n  const combine = (name, value) => {\n    if (map.has(name)) {\n      value = `, ${normalizeValue(value)}`\n    }\n\n    return append(name, value)\n  }\n\n  const remove = (name) => {\n    checkImmutability()\n\n    name = normalizeName(name)\n    return map.delete(name)\n  }\n\n  const entries = () => map.entries()\n\n  const keys = () => map.keys()\n\n  const values = () => map.values()\n\n  const forEach = (fn, bind) => {\n    Array.from(entries()).forEach(([headerName, headerValues]) => {\n      headerValues.forEach((headerValue) => {\n        fn.call(bind, headerName, headerValue)\n      })\n    })\n  }\n\n  const toString = () => {\n    const headers = Array.from(entries()).map(([headerName, headerValues]) => {\n      return `${convertToClientName(headerName)}: ${headerValues.join()}`\n    })\n\n    return headers.join(\"\\r\\n\")\n  }\n\n  const toJSON = () => {\n    const headers = {}\n\n    Array.from(entries()).forEach(([headerName, headerValues]) => {\n      headers[convertToClientName(headerName)] = headerValues\n    })\n\n    return headers\n  }\n\n  const populate = (headers) => {\n    if (typeof headers === \"string\") {\n      headers = parseHeaders(headers)\n    } else if (Symbol.iterator in headers) {\n      Array.from(headers).forEach(([name, values]) => {\n        map.set(name, values)\n      })\n    } else if (typeof headers === \"object\") {\n      Object.keys(headers).forEach((name) => {\n        append(name, headers[name])\n      })\n    }\n  }\n\n  if (headers) {\n    populate(headers)\n  }\n\n  return Object.freeze({\n    has,\n    get,\n    getAll,\n    set,\n    append,\n    combine,\n    [\"delete\"]: remove,\n    [Symbol.iterator]: () => map[Symbol.iterator](),\n    entries,\n    keys,\n    values,\n    forEach,\n    toString,\n    toJSON,\n  })\n}\n"]}