{
  "version": 3,
  "sources": [
    "../../../src/openServer/openServer.js"
  ],
  "names": [
    "REASON_CLOSING",
    "openServer",
    "url",
    "getSignature",
    "createSelfSignature",
    "autoCloseOnExit",
    "autoCloseOnCrash",
    "autoCloseOnError",
    "URL",
    "protocol",
    "hostname",
    "process",
    "platform",
    "Error",
    "nodeServer",
    "agent",
    "http",
    "createServer",
    "global",
    "Agent",
    "privateKey",
    "certificate",
    "https",
    "key",
    "cert",
    "rejectUnauthorized",
    "port",
    "connections",
    "Set",
    "on",
    "connection",
    "delete",
    "add",
    "requestHandlers",
    "addInternalRequestHandler",
    "handler",
    "push",
    "removeListener",
    "addRequestHandler",
    "transform",
    "nodeRequestHandler",
    "clients",
    "closeClients",
    "isError",
    "reason",
    "status",
    "Promise",
    "all",
    "Array",
    "from",
    "map",
    "nodeResponse",
    "headersSent",
    "writeHead",
    "resolve",
    "finished",
    "destroy",
    "nodeRequest",
    "client",
    "listen",
    "reject",
    "error",
    "closed",
    "then",
    "address",
    "closeConnections",
    "forEach",
    "close",
    "requestHandler",
    "length",
    "once",
    "emit",
    "removeAutoCloseOnError",
    "statusCode",
    "statusMessage",
    "wrappedClose",
    "args",
    "removeTeardown",
    "exitReason",
    "listenRequest"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import http from \"http\"\nimport https from \"https\"\nimport { URL } from \"url\"\n// import { addNodeExceptionHandler } from \"./addNodeExceptionHandler.js\"\nimport { createSelfSignature } from \"./createSelfSignature.js\"\nimport { processTeardown } from \"./processTeardown.js\"\nimport { createNodeRequestHandler } from \"./createNodeRequestHandler.js\"\nimport { createSignal } from \"@dmail/signal\"\n\nconst REASON_CLOSING = \"closing\"\n\nexport const openServer = (\n  {\n    // by default listen localhost on a random port in https\n    url = \"https://127.0.0.1:0\",\n    // when port is https you must provide privateKey & certificate\n    getSignature = createSelfSignature,\n    // auto close the server when the process exits (terminal closed, ctrl + C, ...)\n    autoCloseOnExit = true,\n    // auto close the server when an uncaughtException happens\n    // false by default because evenwith my strategy to react on uncaughtException\n    // stack trace is messed up and I don't like to have code executed on error\n    autoCloseOnCrash = true,\n    // auto close when server respond with a 500\n    autoCloseOnError = true,\n  } = {},\n) => {\n  url = new URL(url)\n\n  const protocol = url.protocol\n  const hostname = url.hostname\n\n  if (hostname === \"0.0.0.0\" && process.platform === \"win32\") {\n    // https://github.com/nodejs/node/issues/14900\n    throw new Error(`listening ${hostname} any not available on window`)\n  }\n\n  let nodeServer\n  let agent\n  if (protocol === \"http:\") {\n    nodeServer = http.createServer()\n    agent = global.Agent\n  } else if (protocol === \"https:\") {\n    const { privateKey, certificate } = getSignature()\n    nodeServer = https.createServer({\n      key: privateKey,\n      cert: certificate,\n    })\n    agent = new https.Agent({\n      rejectUnauthorized: false, // allow self signed certificate\n    })\n  } else {\n    throw new Error(`unsupported protocol ${protocol}`)\n  }\n\n  const port = url.port\n\n  const connections = new Set()\n  nodeServer.on(\"connection\", (connection) => {\n    connection.on(\"close\", () => {\n      connections.delete(connection)\n    })\n    connections.add(connection)\n  })\n\n  const requestHandlers = []\n  const addInternalRequestHandler = (handler) => {\n    requestHandlers.push(handler)\n    nodeServer.on(\"request\", handler)\n    return () => {\n      nodeServer.removeListener(\"request\", handler)\n    }\n  }\n\n  const addRequestHandler = (handler, transform) => {\n    const nodeRequestHandler = createNodeRequestHandler({ handler, transform, url })\n    return addInternalRequestHandler(nodeRequestHandler)\n  }\n\n  const clients = new Set()\n\n  const closeClients = ({ isError, reason }) => {\n    let status\n    if (isError) {\n      status = 500\n      // reason = 'shutdown because error'\n    } else {\n      status = 503\n      // reason = 'unavailable because closing'\n    }\n\n    return Promise.all(\n      Array.from(clients).map(({ nodeResponse }) => {\n        if (nodeResponse.headersSent === false) {\n          nodeResponse.writeHead(status, reason)\n        }\n\n        return new Promise((resolve) => {\n          if (nodeResponse.finished === false) {\n            nodeResponse.on(\"finish\", resolve)\n            nodeResponse.on(\"error\", resolve)\n            nodeResponse.destroy(reason)\n          } else {\n            resolve()\n          }\n        })\n      }),\n    )\n  }\n\n  addInternalRequestHandler((nodeRequest, nodeResponse) => {\n    const client = { nodeRequest, nodeResponse }\n\n    clients.add(client)\n    nodeResponse.on(\"finish\", () => {\n      clients.delete(client)\n    })\n  })\n\n  // nodeServer.on(\"upgrade\", (request, socket, head) => {\n  //   // when being requested using a websocket\n  //   // we could also answr to the request ?\n  //   // socket.end([data][, encoding])\n\n  //   console.log(\"upgrade\", { head, request })\n  //   console.log(\"socket\", { connecting: socket.connecting, destroyed: socket.destroyed })\n  // })\n\n  let status = \"opening\"\n\n  const listen = () => {\n    return new Promise((resolve, reject) => {\n      nodeServer.listen(port, hostname, (error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  const closed = createSignal()\n\n  return listen().then(() => {\n    status = \"opened\"\n\n    // in case port is 0 (randomly assign an available port)\n    // https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback\n    const port = nodeServer.address().port\n    url.port = port\n\n    const closeConnections = (reason) => {\n      // should we do this async ?\n      // should we do this before closing the server ?\n      connections.forEach((connection) => {\n        connection.destroy(reason)\n      })\n    }\n\n    let close = ({ isError = false, reason = REASON_CLOSING } = {}) => {\n      if (status !== \"opened\") {\n        throw new Error(`server status must be \"opened\" during close() (got ${status}`)\n      }\n\n      // ensure we don't try to handle request while server is closing\n      requestHandlers.forEach((requestHandler) => {\n        nodeServer.removeListener(\"request\", requestHandler)\n      })\n      requestHandlers.length = 0\n\n      status = \"closing\"\n\n      return new Promise((resolve, reject) => {\n        // closing server prevent it from accepting new connections\n        // but opened connection must be shutdown before the close event is emitted\n        nodeServer.once(\"close\", (error) => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        })\n        nodeServer.close()\n        closeClients({ isError, reason }).then(() => {\n          closeConnections(reason)\n        })\n      }).then(() => {\n        status = \"closed\"\n        closed.emit()\n      })\n    }\n\n    if (autoCloseOnError) {\n      const removeAutoCloseOnError = addInternalRequestHandler((nodeRequest, nodeResponse) => {\n        if (nodeResponse.statusCode === 500) {\n          close({\n            isError: true,\n            // we don't specify the true error object but only a string\n            // identifying the error to avoid sending stacktrace to client\n            // and right now there is no clean way to retrieve error from here\n            reason: nodeResponse.statusMessage || \"internal error\",\n          })\n        }\n      })\n      const wrappedClose = close\n      close = (...args) => {\n        removeAutoCloseOnError()\n        return wrappedClose(...args)\n      }\n    }\n\n    if (autoCloseOnExit) {\n      const removeTeardown = processTeardown((exitReason) => {\n        close({ reason: `server process exiting ${exitReason}` })\n      })\n      const wrappedClose = close\n      close = (...args) => {\n        removeTeardown()\n        return wrappedClose(...args)\n      }\n    }\n\n    if (autoCloseOnCrash) {\n      // and if we do that we have to remove the listener\n      // while closing to avoid closing twice in case\n      // addNodeExceptionHandler((exception) => {\n      //   return close({ reason: exception }).then(\n      //     // to indicates exception is not handled\n      //     () => false,\n      //   )\n      // })\n    }\n\n    return {\n      url,\n      nodeServer,\n      addRequestHandler,\n      agent,\n      close,\n      closed,\n    }\n  })\n}\n\nexport const listenRequest = (nodeServer, requestHandler) => {\n  nodeServer.on(\"request\", requestHandler)\n}\n"
  ]
}