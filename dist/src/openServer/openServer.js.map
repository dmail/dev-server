{"version":3,"sources":["../../../src/openServer/openServer.js"],"names":["REASON_CLOSING","openServer","url","getSignature","autoCloseOnExit","autoCloseOnCrash","autoCloseOnError","protocol","hostname","process","platform","Error","nodeServer","agent","createServer","global","Agent","privateKey","certificate","key","cert","rejectUnauthorized","port","connections","Set","on","connection","add","requestHandlers","addInternalRequestHandler","handler","push","removeListener","addRequestHandler","transform","nodeRequestHandler","clients","closeClients","isError","reason","status","Promise","all","Array","from","map","response","headersSent","writeHead","resolve","finished","destroy","nodeRequest","nodeResponse","client","listen","reject","error","closed","then","address","closeConnections","forEach","close","requestHandler","length","once","emit","removeAutoCloseOnError","statusCode","statusMessage","wrappedClose","removeTeardown","exitReason","listenRequest"],"mappings":"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","file":"openServer.js","sourcesContent":["import http from \"http\"\nimport https from \"https\"\nimport { URL } from \"url\"\n// import { addNodeExceptionHandler } from \"./addNodeExceptionHandler.js\"\nimport { createSelfSignature } from \"./createSelfSignature.js\"\nimport { processTeardown } from \"./processTeardown.js\"\nimport { createNodeRequestHandler } from \"./createNodeRequestHandler.js\"\nimport { createSignal } from \"@dmail/signal\"\n\nconst REASON_CLOSING = \"closing\"\n\nexport const openServer = (\n  {\n    // by default listen localhost on a random port in https\n    url = \"https://127.0.0.1:0\",\n    // when port is https you must provide privateKey & certificate\n    getSignature = createSelfSignature,\n    // auto close the server when the process exits (terminal closed, ctrl + C, ...)\n    autoCloseOnExit = true,\n    // auto close the server when an uncaughtException happens\n    // false by default because evenwith my strategy to react on uncaughtException\n    // stack trace is messed up and I don't like to have code executed on error\n    autoCloseOnCrash = true,\n    // auto close when server respond with a 500\n    autoCloseOnError = true,\n  } = {},\n) => {\n  url = new URL(url)\n\n  const protocol = url.protocol\n  const hostname = url.hostname\n\n  if (hostname === \"0.0.0.0\" && process.platform === \"win32\") {\n    // https://github.com/nodejs/node/issues/14900\n    throw new Error(`listening ${hostname} any not available on window`)\n  }\n\n  let nodeServer\n  let agent\n  if (protocol === \"http:\") {\n    nodeServer = http.createServer()\n    agent = global.Agent\n  } else if (protocol === \"https:\") {\n    const { privateKey, certificate } = getSignature()\n    nodeServer = https.createServer({\n      key: privateKey,\n      cert: certificate,\n    })\n    agent = new https.Agent({\n      rejectUnauthorized: false, // allow self signed certificate\n    })\n  } else {\n    throw new Error(`unsupported protocol ${protocol}`)\n  }\n\n  const port = url.port\n\n  const connections = new Set()\n  nodeServer.on(\"connection\", (connection) => {\n    connection.on(\"close\", () => {\n      connections.delete(connection)\n    })\n    connections.add(connection)\n  })\n\n  const requestHandlers = []\n  const addInternalRequestHandler = (handler) => {\n    requestHandlers.push(handler)\n    nodeServer.on(\"request\", handler)\n    return () => {\n      nodeServer.removeListener(\"request\", handler)\n    }\n  }\n\n  const addRequestHandler = (handler, transform) => {\n    const nodeRequestHandler = createNodeRequestHandler({ handler, transform, url })\n    return addInternalRequestHandler(nodeRequestHandler)\n  }\n\n  const clients = new Set()\n\n  const closeClients = ({ isError, reason }) => {\n    let status\n    if (isError) {\n      status = 500\n      // reason = 'shutdown because error'\n    } else {\n      status = 503\n      // reason = 'unavailable because closing'\n    }\n\n    return Promise.all(\n      Array.from(clients).map(({ response }) => {\n        if (response.headersSent === false) {\n          response.writeHead(status, reason)\n        }\n\n        return new Promise((resolve) => {\n          if (response.finished === false) {\n            response.on(\"finish\", resolve)\n            response.on(\"error\", resolve)\n            response.destroy(reason)\n          } else {\n            resolve()\n          }\n        })\n      }),\n    )\n  }\n\n  addInternalRequestHandler((nodeRequest, nodeResponse) => {\n    const client = { nodeRequest, nodeResponse }\n\n    clients.add(client)\n    nodeResponse.on(\"finish\", () => {\n      clients.delete(client)\n    })\n  })\n\n  // nodeServer.on(\"upgrade\", (request, socket, head) => {\n  //   // when being requested using a websocket\n  //   // we could also answr to the request ?\n  //   // socket.end([data][, encoding])\n\n  //   console.log(\"upgrade\", { head, request })\n  //   console.log(\"socket\", { connecting: socket.connecting, destroyed: socket.destroyed })\n  // })\n\n  let status = \"opening\"\n\n  const listen = () => {\n    return new Promise((resolve, reject) => {\n      nodeServer.listen(port, hostname, (error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  const closed = createSignal()\n\n  return listen().then(() => {\n    status = \"opened\"\n\n    // in case port is 0 (randomly assign an available port)\n    // https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback\n    const port = nodeServer.address().port\n    url.port = port\n\n    const closeConnections = (reason) => {\n      // should we do this async ?\n      // should we do this before closing the server ?\n      connections.forEach((connection) => {\n        connection.destroy(reason)\n      })\n    }\n\n    let close = ({ isError = false, reason = REASON_CLOSING } = {}) => {\n      if (status !== \"opened\") {\n        throw new Error(`server status must be \"opened\" during close() (got ${status}`)\n      }\n\n      // ensure we don't try to handle request while server is closing\n      requestHandlers.forEach((requestHandler) => {\n        nodeServer.removeListener(\"request\", requestHandler)\n      })\n      requestHandlers.length = 0\n\n      status = \"closing\"\n\n      return new Promise((resolve, reject) => {\n        // closing server prevent it from accepting new connections\n        // but opened connection must be shutdown before the close event is emitted\n        nodeServer.once(\"close\", (error) => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        })\n        nodeServer.close()\n        closeClients({ isError, reason }).then(() => {\n          closeConnections(reason)\n        })\n      }).then(() => {\n        status = \"closed\"\n        closed.emit()\n      })\n    }\n\n    if (autoCloseOnError) {\n      const removeAutoCloseOnError = addInternalRequestHandler((nodeRequest, nodeResponse) => {\n        if (nodeResponse.statusCode === 500) {\n          close({\n            isError: true,\n            // we don't specify the true error object but only a string\n            // identifying the error to avoid sending stacktrace to client\n            // and right now there is no clean way to retrieve error from here\n            reason: nodeResponse.statusMessage || \"internal error\",\n          })\n        }\n      })\n      const wrappedClose = close\n      close = (...args) => {\n        removeAutoCloseOnError()\n        return wrappedClose(...args)\n      }\n    }\n\n    if (autoCloseOnExit) {\n      const removeTeardown = processTeardown((exitReason) => {\n        close({ reason: `server process exiting ${exitReason}` })\n      })\n      const wrappedClose = close\n      close = (...args) => {\n        removeTeardown()\n        return wrappedClose(...args)\n      }\n    }\n\n    if (autoCloseOnCrash) {\n      // and if we do that we have to remove the listener\n      // while closing to avoid closing twice in case\n      // addNodeExceptionHandler((exception) => {\n      //   return close({ reason: exception }).then(\n      //     // to indicates exception is not handled\n      //     () => false,\n      //   )\n      // })\n    }\n\n    return {\n      url,\n      nodeServer,\n      addRequestHandler,\n      agent,\n      close,\n      closed,\n    }\n  })\n}\n\nexport const listenRequest = (nodeServer, requestHandler) => {\n  nodeServer.on(\"request\", requestHandler)\n}\n"]}