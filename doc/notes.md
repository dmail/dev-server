## TODO

- source code -> all code referenced by index.js
  will fails to find projectFolder using import.meta.require() because the bundled file
  will be elsewhere

launchNode, bundleBrowser, bundleNode, startCompileServer are using this

in all thoose cases the idea is to get a file which is precompiled
we could precompile it next to the source file so that
source file will find it when runned directly
and also put it inside dist/ so that once compiled it find the file as well

but the idea is more to have some kind of
DIST_FOLDER which is either `${projectFolder}/dist` for the source file
and is ./ for the file already inside dist
a good way to do this ?

because even midterm we will use the node bundled version of jsenv/core.
external user of the lib needs the file to look inside './nodeClient.js'
but while working on jsenv launchNode needs something like '../../../dist/nodeClient.js'

- There is also import.meta.require() on babel-transform-modules-systemjs written in cjs
  which will fail
  -> easy fix: use the import/export version
  available here: https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-modules-systemjs/src/index.js
  and add the async wrapping I need

### How to use dependency written in commonjs

Some module now have `module` or `jsnext:main` in their `package.json` leading to files written using `import/export`. In that case `importMap.json` generated by `generate-import-map` will contain a remapping to this file and you're good.

Otherwise if you want to use a npm module called `awesome` written using `module.exports`, you can

(a) Use `import.meta.require` if you know your code is meant to be executed only on node:

```js
const awesome = import.meta.require("awesome")
```

(b) Manually convert it to `import/export`:

- Fork the github repository
- Run an automatic tool to transform `module.exports` into `import/export`. For instance https://github.com/tbranyen/babel-plugin-transform-commonjs.
- Ensure dependency still works, you may run npm test for that.
- Open a PR with the code written using `import/export` or use your fork directly.

You can reuse this strategy for dependency written in iife, amd or umd.

## Generator not supported

Because we miss a strategy to provide regeneratorRuntime and polyfill in general.

## Sourcemap broken

It's likely because `transform-async-to-promises` used together with `transform-modules-systemjs` generate bad sourcemap.
It means if you use async/await in a platform not supporting it, your sourcemap will not be able to point the original location.
