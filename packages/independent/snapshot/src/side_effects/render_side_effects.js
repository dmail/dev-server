import { replaceFluctuatingValues } from "../replace_fluctuating_values.js";

export const createDetailsOnMaxLineCondition =
  (maxLines) => (sideEffect, text) => {
    if (text.split("\n").length > maxLines) {
      return {
        open: false,
      };
    }
    return null;
  };

export const renderSideEffects = (
  sideEffects,
  {
    generatedBy = true,
    titleLevel = 1,
    shouldUseDetails = createDetailsOnMaxLineCondition(5),
  } = {},
) => {
  const { rootDirectoryUrl, replaceFilesystemWellKnownValues } =
    sideEffects.options;

  const replace = (value, options) => {
    return replaceFluctuatingValues(value, {
      replaceFilesystemWellKnownValues,
      rootDirectoryUrl,
      ...options,
    });
  };

  let markdown = "";
  let sideEffectNumber = 0;
  let sideEffectNumberMap = new Map();
  for (const sideEffect of sideEffects) {
    if (sideEffect.skippable) {
      continue;
    }
    if (sideEffect.type === "source_code") {
      continue;
    }
    sideEffectNumber++;
    sideEffectNumberMap.set(sideEffect, sideEffectNumber);
  }
  const lastSideEffectNumber = sideEffectNumber;

  for (const sideEffect of sideEffects) {
    if (sideEffect.skippable) {
      continue;
    }
    if (markdown) {
      markdown += "\n\n";
    }
    const { render } = sideEffect;
    if (typeof render !== "object") {
      throw new TypeError(
        `sideEffect.render should be an object, got ${render} on side effect with type "${sideEffect.type}"`,
      );
    }
    const { md } = sideEffect.render;
    const { label, text } = md({ replace, rootDirectoryUrl });
    if (sideEffect.type === "source_code") {
      markdown += text;
      continue;
    }
    if (label) {
      const sideEffectNumber = sideEffectNumberMap.get(sideEffect);
      const stepTitle = `${"#".repeat(titleLevel)} ${sideEffectNumber}/${lastSideEffectNumber} ${label}`;
      markdown += stepTitle;
      if (text) {
        const shouldUseDetailsResult = shouldUseDetails(sideEffect, text);
        if (shouldUseDetailsResult) {
          const { open } = shouldUseDetailsResult;
          markdown += "\n";
          markdown += renderMarkdownDetails(text, {
            open,
            summary: "details",
          });
        } else {
          markdown += "\n\n";
          markdown += text;
        }
      }
    } else {
      markdown += text;
    }
  }
  if (generatedBy) {
    let generatedByLink = `Generated by [@jsenv/snapshot](https://github.com/jsenv/core/tree/main/packages/independent/snapshot)`;
    markdown += "\n\n";
    markdown += generatedByLink;
  }
  return markdown;
};

export const renderMarkdownDetails = (text, { open, summary, indent = 0 }) => {
  return `${"  ".repeat(indent)}<details${open ? " open" : ""}>
${"  ".repeat(indent + 1)}<summary>${summary}</summary>

${text}
</details>`;
  // ${"  ".repeat(indent)}</details>`;
};

export const wrapIntoMarkdownBlock = (value, blockName = "") => {
  const start = "```";
  const end = "```";
  return `${start}${blockName}
${value}
${end}`;
};
