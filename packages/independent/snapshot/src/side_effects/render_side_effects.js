import { createException } from "@jsenv/exception";
import { urlToExtension } from "@jsenv/urls";
import { replaceFluctuatingValues } from "../replace_fluctuating_values.js";

export const createDetailsOnMaxLineCondition =
  (maxLines) => (sideEffect, text) => {
    if (text.split("\n").length > maxLines) {
      return {
        open: false,
      };
    }
    return null;
  };

export const renderSideEffects = (
  sideEffects,
  {
    sideEffectFileUrl,
    outDirectoryUrl,
    generatedBy = true,
    titleLevel = 1,
    shouldUseDetails = createDetailsOnMaxLineCondition(5),
  } = {},
) => {
  const { rootDirectoryUrl, replaceFilesystemWellKnownValues } =
    sideEffects.options;

  const replace = (value, options) => {
    return replaceFluctuatingValues(value, {
      replaceFilesystemWellKnownValues,
      rootDirectoryUrl,
      ...options,
    });
  };

  let markdown = "";
  let sideEffectNumber = 0;
  for (const sideEffect of sideEffects) {
    if (sideEffect.skippable) {
      continue;
    }
    if (sideEffect.type === "source_code") {
      continue;
    }
    sideEffectNumber++;
    sideEffect.number = sideEffectNumber;
  }
  const lastSideEffectNumber = sideEffectNumber;

  for (const sideEffect of sideEffects) {
    if (sideEffect.skippable) {
      continue;
    }
    if (markdown) {
      markdown += "\n\n";
    }
    markdown += renderOneSideEffect(sideEffect, {
      sideEffectFileUrl,
      outDirectoryUrl,
      rootDirectoryUrl,
      titleLevel,
      shouldUseDetails,
      replace,
      lastSideEffectNumber,
    });
  }
  if (generatedBy) {
    let generatedByLink = `Generated by [@jsenv/snapshot](https://github.com/jsenv/core/tree/main/packages/independent/snapshot)`;
    markdown += "\n\n";
    markdown += generatedByLink;
  }
  return markdown;
};

const renderOneSideEffect = (
  sideEffect,
  {
    sideEffectFileUrl,
    outDirectoryUrl,
    rootDirectoryUrl,
    titleLevel,
    shouldUseDetails,
    replace,
    lastSideEffectNumber,
  },
) => {
  const { render } = sideEffect;
  if (typeof render !== "object") {
    throw new TypeError(
      `sideEffect.render should be an object, got ${render} on side effect with type "${sideEffect.type}"`,
    );
  }
  const { md } = sideEffect.render;
  let { label, text } = md({
    sideEffectFileUrl,
    outDirectoryUrl,
    replace,
    rootDirectoryUrl,
  });
  if (text) {
    text = renderText(text, { replace, rootDirectoryUrl });
  }
  if (sideEffect.type === "source_code") {
    return text;
  }
  if (!label) {
    return text;
  }
  const stepTitle = `${"#".repeat(titleLevel)} ${sideEffect.number}/${lastSideEffectNumber} ${replace(label)}`;
  if (!text) {
    return stepTitle;
  }
  const shouldUseDetailsResult = shouldUseDetails(sideEffect, text);
  if (!shouldUseDetailsResult) {
    return `${stepTitle}

${text}`;
  }
  const { open } = shouldUseDetailsResult;
  return `${stepTitle}

${renderMarkdownDetails(text, {
  open,
  summary: "details",
})}`;
};

// TODO: when text contains ANSI, we should generate a SVG
// to properly reflect the output
// the SVG would be written by default to urlToFilename(sideEffectFileUrl)/
// et pour le nom du svg on mettra euhhh
// ./error.svg
// ./console_log_1.svg
// ./console_log_2.svg
// par example
// pour les test on auras scenario avant genre
// ./boolean/true_should_be_false_error.svg
// on utilisera renderTerminalSvg mais sans le header avec le titre
const renderText = (
  text,
  {
    replace,
    // outDirectoryUrl,
    rootDirectoryUrl,
  },
) => {
  if (text && typeof text === "object") {
    if (text.type === "source_code") {
      return wrapIntoMarkdownBlock(text.value, "js");
    }
    if (text.type === "js_value") {
      const value = text.value;
      if (value === undefined) {
        return wrapIntoMarkdownBlock("undefined", "js");
      }
      if (
        value instanceof Error ||
        (value &&
          value.constructor &&
          value.constructor.name.includes("Error") &&
          value.stack &&
          typeof value.stack === "string")
      ) {
        const exception = createException(text.value, { rootDirectoryUrl });
        const exceptionText = replace(
          exception
            ? exception.stack || exception.message || exception
            : String(exception),
          {
            stringType: "error",
          },
        );
        return wrapIntoMarkdownBlock(exceptionText, "");
      }
      return wrapIntoMarkdownBlock(
        replace(JSON.stringify(value, null, "  "), {
          stringType: "json",
        }),
        "js",
      );
    }
    if (text.type === "console") {
      return wrapIntoMarkdownBlock(
        replace(text.value, { stringType: "console" }),
        "console",
      );
    }
    if (text.type === "file_content") {
      return renderFileContent(text, { replace });
    }
  }
  return replace(text);
};

export const renderFileContent = (text, { replace }) => {
  const { url } = text;
  let content = text.value;
  const extension = urlToExtension(url).slice(1);
  if (extension === "md") {
    let escaped = "";
    for (const char of content.split("")) {
      if (
        [
          "`",
          "*",
          "_",
          "{",
          "}",
          "[",
          "]",
          "(",
          ")",
          "#",
          "+",
          "-",
          ".",
          "!",
        ].includes(char)
      ) {
        escaped += `\\${char}`;
      } else {
        escaped += char;
      }
    }
    content = escaped;
  }
  return wrapIntoMarkdownBlock(replace(content, { fileUrl: url }), extension);
};

export const renderMarkdownDetails = (text, { open, summary, indent = 0 }) => {
  return `${"  ".repeat(indent)}<details${open ? " open" : ""}>
${"  ".repeat(indent + 1)}<summary>${summary}</summary>

${text}

${"  ".repeat(indent)}</details>`;
};

export const wrapIntoMarkdownBlock = (value, blockName = "") => {
  const start = "```";
  const end = "```";
  return `${start}${blockName}
${value}
${end}`;
};
