import { writeFileSync } from "@jsenv/filesystem";
import { urlToBasename, urlToFilename, urlToRelativeUrl } from "@jsenv/urls";
import { takeDirectorySnapshot } from "../filesystem_snapshot.js";
import { getCallerLocation } from "../get_caller_location.js";
import { createCaptureSideEffects } from "./create_capture_side_effects.js";
import { renderSideEffects, renderSmallLink } from "./render_side_effects.js";

/**
 * Generate a markdown file describing test(s) side effects. When executed in CI throw if there is a diff.
 * @param {URL} sourceFileUrl
 * @param {Function} fnRegisteringTest
 * @param {Object} snapshotTestsOptions
 * @param {string|url} snapshotTestsOptions.outFilePattern
 * @param {string|url} snapshotTestsOptions.rootDirectoryUrl
 * @param {Object} [snapshotTestsOptions.filesystemActions]
 *        Control what to do when there is a file side effect
 *        "compare", "compare_presence_only", "undo", "ignore"
 * @param {Object|boolean} [snapshotTestsOptions.filesystemEffects]
 * @param {boolean} [snapshotTestsOptions.filesystemEffects.textualFilesInline=false]
 *        Put textual files content in the markdown (instead of separate files).
 *        Big files will still be put in dedicated files.
 * @param {boolean} [snapshotTestsOptions.filesystemEffects.preserve=false]
 *        Preserve filesystem side effect when function ends. By default
 *        filesystem effects are undone when function ends
 * @param {url} [snapshotTestsOptions.filesystemEffects.baseDirectory]
 *        Urls of filesystem side effects will be relative to this base directory
 *        Default to the directory containing @sourceFileUrl
 */
export const snapshotTests = async (
  sourceFileUrl,
  fnRegisteringTest,
  {
    outFilePattern = "./_[source_filename]/[filename]",
    filesystemActions = {
      "**": "compare",
      // "**/*.svg": "compare_presence_only",
    },
    rootDirectoryUrl,
    generatedBy = true,
    linkToSource = true,
    linkToEachSource,
    errorTransform,
    logEffects,
    filesystemEffects,
    throwWhenDiff = process.env.CI,
  } = {},
) => {
  filesystemActions = {
    ...filesystemActions,
    "**/*.svg": "presence_only",
  };

  const sourceName = urlToBasename(sourceFileUrl, true);
  const sourceBasename = urlToBasename(sourceFileUrl);
  const sourceFilename = urlToFilename(sourceFileUrl);
  const generateOutFileUrl = (outFilename) => {
    const outFileRelativeUrl = outFilePattern
      .replaceAll("[source_name]", sourceName)
      .replaceAll("[source_basename]", sourceBasename)
      .replaceAll("[source_filename]", sourceFilename)
      .replaceAll("[filename]", outFilename);
    const outFileUrl = new URL(outFileRelativeUrl, sourceFileUrl).href;
    return outFileUrl;
  };
  const outDirectoryUrl = generateOutFileUrl("");
  const sideEffectMdFileUrl = generateOutFileUrl(`${sourceFilename}.md`);

  const dirUrlMap = new Map();
  const sideEffectsMap = new Map();
  const testMap = new Map();
  const onlyTestMap = new Map();
  const test = (scenario, fn, options) => {
    if (testMap.has(scenario) || onlyTestMap.has(scenario)) {
      console.warn(`test override "${scenario}"`);
    }
    testMap.set(scenario, { fn, options, callSite: getCallerLocation(2) });
  };
  test.ONLY = (scenario, fn, options) => {
    if (testMap.has(scenario) || onlyTestMap.has(scenario)) {
      console.warn(`test override "${scenario}"`);
    }
    onlyTestMap.set(scenario, { fn, options, callSite: getCallerLocation(2) });
  };
  const fnReturnValue = await fnRegisteringTest({ test });

  let activeTestMap;
  const toIgnoreActions = {};
  if (onlyTestMap.size) {
    activeTestMap = onlyTestMap;
    for (const [scenario] of testMap) {
      const testScenario = asValidFilename(scenario);
      const generateScenarioOutFileUrl = (outfilename) => {
        return generateOutFileUrl(`${testScenario}/${outfilename}`);
      };
      const scenarioOutDirectoryUrl = generateScenarioOutFileUrl("");
      toIgnoreActions[scenarioOutDirectoryUrl] = "ignore";
    }
  } else {
    activeTestMap = testMap;
  }
  // ignore tout ceux aui sont désactivé
  const outDirectorySnapshot = takeDirectorySnapshot(outDirectoryUrl, {
    ...filesystemActions,
    ...toIgnoreActions,
  });
  const captureSideEffects = createCaptureSideEffects({
    sourceFileUrl,
    rootDirectoryUrl,
    logEffects,
    filesystemEffects,
    filesystemActions,
  });
  let markdown = "";
  markdown += `# ${sourceName}`;
  if (generatedBy) {
    let generatedByLink = renderSmallLink(
      {
        text: "@jsenv/snapshot",
        href: "https://github.com/jsenv/core/tree/main/packages/independent/snapshot",
      },
      {
        prefix: "Generated by ",
        suffix:
          linkToSource && sourceFileUrl
            ? generateExecutingLink(sourceFileUrl, sideEffectMdFileUrl)
            : "",
      },
    );
    markdown += "\n\n";
    markdown += generatedByLink;
  }
  const scenarioDirs = [];
  for (const [scenario, { fn, callSite }] of activeTestMap) {
    markdown += "\n\n";
    markdown += `## ${scenario}`;
    markdown += "\n\n";
    const sideEffects = await captureSideEffects(fn, {
      callSite: linkToEachSource ? callSite : undefined,
      baseDirectory: String(new URL("./", callSite.url)),
    });
    sideEffectsMap.set(scenario, sideEffects);
    const testScenario = asValidFilename(scenario);
    scenarioDirs.push(testScenario);
    const generateScenarioOutFileUrl = (outfilename) => {
      return generateOutFileUrl(`${testScenario}/${outfilename}`);
    };
    const scenarioOutDirectoryUrl = generateScenarioOutFileUrl("");
    dirUrlMap.set(scenario, scenarioOutDirectoryUrl);
    const sideEffectsMarkdown = renderSideEffects(sideEffects, {
      sideEffectMdFileUrl,
      generateOutFileUrl: generateScenarioOutFileUrl,
      generatedBy: false,
      titleLevel: 3,
      errorTransform,
    });
    markdown += sideEffectsMarkdown;
  }
  if (typeof fnReturnValue === "function") {
    await fnReturnValue();
  }
  // if (sideEffectFilePattern === "./side_effects/[filename]/[filename].md") {
  //   const scenarioParentDirUrl = new URL("./", sideEffectFileUrl);
  //   const dirContent = readDirectorySync(scenarioParentDirUrl);
  //   for (const entry of dirContent) {
  //     const entryUrl = new URL(entry, scenarioParentDirUrl);
  //     if (!readEntryStatSync(entryUrl).isDirectory()) {
  //       continue;
  //     }
  //     if (scenarioDirs.includes(entry)) {
  //       continue;
  //     }
  //     removeDirectorySync(entryUrl, {
  //       recursive: true,
  //     });
  //   }
  // }
  writeFileSync(sideEffectMdFileUrl, markdown);
  outDirectorySnapshot.compare(throwWhenDiff);

  return { dirUrlMap, sideEffectsMap };
};

const generateExecutingLink = (sourceFileUrl, sideEffectFileUrl) => {
  const relativeUrl = urlToRelativeUrl(sourceFileUrl, sideEffectFileUrl, {
    preferRelativeNotation: true,
  });
  const href = `${relativeUrl}`;
  const text = `${relativeUrl}`;
  return ` executing <a href="${href}">${text}</a>`;
};

// see https://github.com/parshap/node-sanitize-filename/blob/master/index.js
const asValidFilename = (string) => {
  return string
    .trim()
    .toLowerCase()
    .replace(/[ ,.]/g, "_")
    .replace(/["/?<>\\:*|]/g, "");
};
