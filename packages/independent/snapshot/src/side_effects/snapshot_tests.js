import { urlToBasename, urlToRelativeUrl } from "@jsenv/urls";
import {
  takeDirectorySnapshot,
  takeFileSnapshot,
} from "../filesystem_snapshot.js";
import { getCallerLocation } from "../get_caller_location.js";
import { createCaptureSideEffects } from "./create_capture_side_effects.js";
import { renderSideEffects, renderSmallLink } from "./render_side_effects.js";

/**
 * Generate a markdown file describing all test side effects. When executed in CI throw if there is a diff.
 * @param {URL} testFileUrl
 * @param {Function} fnRegisteringTest
 * @param {Object} snapshotTestsOptions
 * @param {string|url} snapshotTestsOptions.sideEffectFileUrl
 * @param {string|url} snapshotTestsOptions.rootDirectoryUrl
 * @return {Array.<Object>} sideEffects
 */
export const snapshotTests = async (
  testFileUrl,
  fnRegisteringTest,
  {
    testName = urlToBasename(testFileUrl, true),
    sideEffectFileUrl,
    outDirectoryPattern = "./side_effects/",
    sideEffectFilePattern = "./side_effects/[test_basename].md",
    outFilePattern = "./side_effects/[test_name]/[test_scenario]/[filename]",
    rootDirectoryUrl,
    generatedBy = true,
    linkToSource = true,
    linkToEachSource,
    errorStackHidden,
    errorMessageTransform,
    logEffects,
    filesystemEffects,
    throwWhenDiff = process.env.CI,
  } = {},
) => {
  const testBasename = urlToBasename(testFileUrl);
  if (sideEffectFileUrl === undefined) {
    const sideEffectFileRelativeUrl = sideEffectFilePattern
      .replaceAll("[test_name]", testName)
      .replaceAll("[test_basename]", testBasename);
    sideEffectFileUrl = new URL(sideEffectFileRelativeUrl, testFileUrl);
  } else {
    sideEffectFileUrl = new URL(sideEffectFileUrl, testFileUrl);
  }

  const dirUrlMap = new Map();
  const sideEffectsMap = new Map();
  const testMap = new Map();
  const onlyTestMap = new Map();
  const test = (scenario, fn, options) => {
    if (testMap.has(scenario) || onlyTestMap.has(scenario)) {
      console.warn(`test override "${scenario}"`);
    }
    testMap.set(scenario, { fn, options, callSite: getCallerLocation(2) });
  };
  test.ONLY = (scenario, fn, options) => {
    if (testMap.has(scenario) || onlyTestMap.has(scenario)) {
      console.warn(`test override "${scenario}"`);
    }
    onlyTestMap.set(scenario, { fn, options, callSite: getCallerLocation(2) });
  };
  fnRegisteringTest({ test });

  const activeTestMap = onlyTestMap.size ? onlyTestMap : testMap;
  const captureSideEffects = createCaptureSideEffects({
    rootDirectoryUrl,
    logEffects,
    filesystemEffects,
  });
  let markdown = "";
  markdown += `# ${testName}`;
  if (generatedBy) {
    let generatedByLink = renderSmallLink(
      {
        text: "@jsenv/snapshot",
        href: "https://github.com/jsenv/core/tree/main/packages/independent/snapshot",
      },
      {
        prefix: "Generated by ",
        suffix:
          linkToSource && testFileUrl
            ? generateExecutingLink(testFileUrl, sideEffectFileUrl)
            : "",
      },
    );
    markdown += "\n\n";
    markdown += generatedByLink;
  }

  const outDirectoryRelativeUrl = outDirectoryPattern.replaceAll(
    "[test_name]",
    testName,
  );
  const outDirectoryUrl = new URL(outDirectoryRelativeUrl, testFileUrl);
  const outFileDirectorySnapshots = [];
  for (const [scenario, { fn, callSite }] of activeTestMap) {
    markdown += "\n\n";
    markdown += `## ${scenario}`;
    markdown += "\n\n";
    const sideEffects = await captureSideEffects(fn, {
      callSite: linkToEachSource ? callSite : undefined,
      baseDirectory: String(new URL("./", callSite.url)),
    });
    sideEffectsMap.set(scenario, sideEffects);
    const testScenario = asValidFilename(scenario);
    const generateOutFileUrl = (filename) => {
      const outFileRelativeUrl = outFilePattern
        .replaceAll("[test_name]", testName)
        .replaceAll("[test_basename]", testBasename)
        .replaceAll("[test_scenario]", testScenario)
        .replaceAll("[filename]", filename);
      const outFileUrl = new URL(outFileRelativeUrl, testFileUrl).href;
      return outFileUrl;
    };
    const outFileDirectoryUrl = generateOutFileUrl("");
    const outFileDirectorySnapshot = takeDirectorySnapshot(
      outFileDirectoryUrl,
      {
        "**/*": true,
        "**/*.svg": "presence_only",
      },
    );
    outFileDirectorySnapshots.push(outFileDirectorySnapshot);
    dirUrlMap.set(scenario, outFileDirectoryUrl);
    const sideEffectsMarkdown = renderSideEffects(sideEffects, {
      sideEffectFileUrl,
      outDirectoryUrl,
      generateOutFileUrl,
      generatedBy: false,
      titleLevel: 3,
      errorStackHidden,
      errorMessageTransform,
    });
    markdown += sideEffectsMarkdown;
  }
  const sideEffectFileSnapshot = takeFileSnapshot(sideEffectFileUrl);
  sideEffectFileSnapshot.update(markdown, {
    mockFluctuatingValues: false,
    throwWhenDiff,
  });
  for (const outFileDirectorySnapshot of outFileDirectorySnapshots) {
    outFileDirectorySnapshot.compare(throwWhenDiff);
  }

  return { dirUrlMap, sideEffectsMap };
};

const generateExecutingLink = (sourceFileUrl, sideEffectFileUrl) => {
  const relativeUrl = urlToRelativeUrl(sourceFileUrl, sideEffectFileUrl, {
    preferRelativeNotation: true,
  });
  const href = `${relativeUrl}`;
  const text = `${relativeUrl}`;
  return ` executing <a href="${href}">${text}</a>`;
};

// see https://github.com/parshap/node-sanitize-filename/blob/master/index.js
const asValidFilename = (string) => {
  return string
    .trim()
    .toLowerCase()
    .replace(/[ ,.]/g, "_")
    .replace(/["/?<>\\:*|]/g, "");
};
