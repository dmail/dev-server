<!doctype html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8" />
    <link rel="icon" href="data:," />
  </head>

  <body>
    <div style="display: flex">
      <div id="terminal"></div>
      <canvas id="canvas"></canvas>
    </div>
    <script>
      window.xtreamReadyPromise = new Promise((resolve) => {
        window.resolveXtermReadyPromise = resolve;
      });
    </script>
    <script type="module">
      /*
       on veut pouvoir:
       - mettre le terminal dans un "fake terminal" genre
       avec le style de celui svg
       - enregister une vidéo du terminal
       ça faut que je regarde les apis canvas

       https://github.com/welefen/canvas2video/blob/master/src/index.ts
       https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/captureStream
       https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder
       https://webglfundamentals.org/webgl/lessons/webgl-tips.html
       https://github.com/xtermjs/xterm.js/blob/master/typings/xterm.d.ts
       */

      import "xterm";
      import "xterm-addon-canvas";

      const { Terminal } = window;
      const { CanvasAddon } = window.CanvasAddon;
      const cssUrl = new URL("xterm/css/xterm.css", import.meta.url);
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = cssUrl;
      document.head.appendChild(link);

      window.initTerminal = ({ cols = 80 } = {}) => {
        const term = new Terminal({
          convertEol: true,
          disableStdin: true,
          // cursorBlink: false,
          cursorInactiveStyle: "none",
          cols,
          rows: 20,
          fontFamily: "SauceCodePro Nerd Font, Source Code Pro, Courier",
          fontSize: 14,
          // lineHeight: 18,
          theme: {
            background: "#282c34",
            foreground: "#abb2bf",
            selectionBackground: "#001122",
            selectionForeground: "#777777",
            brightRed: "#B22222",
            brightBlue: "#87CEEB",
          },
        });
        term.loadAddon(new CanvasAddon());
        const terminalElement = document.getElementById("terminal");
        term.open(terminalElement);

        const canvas = document.querySelector("#canvas");
        const context = canvas.getContext("2d");

        const xtermCanvas = document.querySelector("canvas.xterm-text-layer");
        canvas.width = xtermCanvas.width;
        canvas.height = xtermCanvas.height;

        window.startRecording = async ({
          mimeType = "video/webm;codecs=h264",
        } = {}) => {
          const replicateOnCanvas = () => {
            context.drawImage(
              xtermCanvas,
              0,
              0,
              canvas.width,
              canvas.height,
              0,
              0,
              canvas.width,
              canvas.height,
            );
          };
          setInterval(replicateOnCanvas, 25);

          const stream = canvas.captureStream();
          const mediaRecorder = new MediaRecorder(stream, {
            videoBitsPerSecond: 2_500_000,
            mimeType,
          });
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size) {
              chunks.push(e.data);
            }
          };
          const startPromise = new Promise((resolve) => {
            mediaRecorder.onstart = resolve;
          });
          mediaRecorder.start();
          await startPromise;

          window.writeIntoTerminal = (data) => {
            term.write(data);
            replicateOnCanvas();
          };
          window.stopRecording = async () => {
            replicateOnCanvas();
            await new Promise((resolve) => {
              setTimeout(resolve, 50);
            });
            const stopPromise = new Promise((resolve, reject) => {
              mediaRecorder.onstop = () => {
                resolve();
              };
              mediaRecorder.onerror = (e) => {
                reject(e);
              };
            });
            mediaRecorder.stop();
            await stopPromise;
            const blob = new Blob(chunks, {
              type: mediaRecorder.mimeType,
            });
            return blobToBinaryString(blob);
          };
        };
      };

      const blobToBinaryString = (blob) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsBinaryString(blob);
        });
      };

      window.resolveXtermReadyPromise();
    </script>
  </body>
</html>
