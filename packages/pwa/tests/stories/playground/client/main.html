<!-- 
https://web.dev/service-worker-lifecycle/

Test a faire:
- 2 tabs + reload required 
- same on firefox
- same on safari
- 1 tab reload de l'image
- comme le précédant mais on en fait plusieurs pour voir que ça marche
- 2 tab reload de l'image
- erreur pendant top level pendant register initial
- erreur pendant le install initial
- erreur pendant le activate ininitial
  -> tous ces cas a priori on veut juste qu'on puisse le savoir + un log
  mais rien de plus
- erreur top level dans l'update
- erreur install dans l'update
- erreur activate dans l'update
  -> ici par contre on veut plus d'info pour que la ui puisse choisir de l'afficher
  a piori une promesse comme ça on a le unhandled rejection si la ui s'en fou
  mais sinon elle peut réagir
  ou alors une fonction onError, si elle est pas passé on throw, sinon on l'apelle -> mieux oui
- erreur dans la fonction qui permet d'apply l'update 
  (a priori on indique l'erreur + indique que c'est méga grave et il faut recharger la page pour fixer)
- erreur 404 pendant register initial

Quand on en sera la il sera temps de tester avec le vrai build de jsenv
Et aussi il faudra un test ou on renomme le script du worker
et donc l'éxecution du html va register un nouveau script
on voudras voir comment ça se comporte

comment on fait pour reload les autres tabs?
est ce que un autre tab reçoit aussi le "updatefound"
est ce alors une bonne idée de détecter que c'est un tab en background?
ou alors il veut mieux que ce soit le tab actif qui lui dise quoi faire?
ou alors que un tab inactif juste se reload lorsqu'il devient actif pour éviter ce souci? 
(ça a l'air bien ça)

Ne pas oublier de tester ce qui se passe si on fait 2 "updatefound"
hot reloadable d'affilé, voir un 3eme
      
-->

<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8" />
    <link rel="icon" href="data:," />
  </head>

  <body>
    <div id="animal_ui">
      <fieldset>
        <legend>Animal image <button id="refresh">refresh</button></legend>
        <img style="display: block" height="200" src="./animal.svg?v=dog" />
      </fieldset>
    </div>
    <div id="service_worker_ui">
      <fieldset>
        <legend>Service worker script</legend>
        <button id="register" disabled>register sw.js</button>
        <button id="unregister" disabled>unregister</button>
        <br />
        <br />
        <button id="update_check_button" disabled>Check for updates</button>
        <div id="update_downloading_message" style="display: none">
          Downloading update...
        </div>
        <button id="update_by_restart_button" disabled>
          Restart to update
        </button>
        <button id="update_now_button" disabled>Apply update</button>

        <br />
        <br />
        Navigator controller: <span id="controller"></span>
        <br />
        Current version: <span id="current_version"></span>
        <br />
        Update version: <span id="update_version"></span>
      </fieldset>
    </div>
    <div id="trigger_file_changes">
      <fieldset>
        <legend>Update files</legend>
        <button id="build_dog">Build dog</button>
        <button id="build_horse">Build horse</button>
        <button id="build_cat">Build cat</button>
        <button id="build_sw_script">Build sw script</button>
      </fieldset>
    </div>

    <script>
      const serviceWorkerAPI = window.navigator.serviceWorker

      let currentSwInfoPromise = null
      const controllerSpan = document.querySelector("#controller")
      const updateController = () => {
        const { controller } = serviceWorkerAPI
        if (controller) {
          controllerSpan.innerHTML = "yes"
        } else {
          controllerSpan.innerHTML = "no"
        }
      }
      updateController()
      serviceWorkerAPI.addEventListener("controllerchange", () => {
        updateController()
      })

      const postMessageToServiceWorker = (serviceWorker, message) => {
        const { port1, port2 } = new MessageChannel()
        return new Promise((resolve, reject) => {
          port1.onmessage = function (event) {
            if (event.data.status === "rejected") {
              reject(event.data.payload)
            } else {
              resolve(event.data.payload)
            }
          }
          serviceWorker.postMessage(message, [port2])
        })
      }
      // eslint-disable-next-line no-unused-vars
      const postMessageToCurrentServiceWorker = async (message) => {
        const controller = serviceWorkerAPI.controller
        if (controller) {
          return postMessageToServiceWorker(controller, message)
        }
        const registration = await serviceWorkerAPI.getRegistration()
        if (!registration) {
          throw new Error("no service worker registered to communicate with")
        }
        return postMessageToServiceWorker(
          registration.installing ||
            registration.waiting ||
            registration.active,
          message,
        )
      }
      const inspectServiceWorker = async (serviceWorker) => {
        let serviceWorkerResponse
        console.log(`inspect ${serviceWorker.scriptURL}`)
        const inspectPromise = postMessageToServiceWorker(serviceWorker, {
          action: "inspect",
        }).then((info) => {
          console.log(`${serviceWorker.scriptURL} inspect result ->`, info)
          serviceWorkerResponse = info
        })
        let timeout
        let timeoutReached = false
        const timeoutPromise = new Promise((resolve) => {
          timeout = setTimeout(() => {
            timeoutReached = true
            resolve()
          }, 1000)
        })
        await Promise.race([inspectPromise, timeoutPromise])
        clearTimeout(timeout)
        if (timeoutReached) {
          return null
        }
        return serviceWorkerResponse
      }
      const requestSkipWaiting = (serviceWorker) => {
        console.log("send skipWaiting")
        postMessageToServiceWorker(serviceWorker, {
          action: "skipWaiting",
        })
      }
      const requestClaim = (serviceWorker) => {
        console.log("send claim")
        return postMessageToServiceWorker(serviceWorker, {
          action: "claim",
        })
      }

      const createApplyUpdate = ({ updateInfo, currentInfo }) => {
        const actions = []
        if (!currentInfo || !currentInfo.resources) {
          return null
        }
        if (!updateInfo || !updateInfo.resources) {
          return null
        }
        const currentResources = currentInfo.resources
        const newResources = updateInfo.resources
        for (const currentResource of currentResources) {
          const hotResource = hotResources[currentResource.url]
          if (!hotResource) {
            return null
          }
          const newResource = newResources.find(
            (newResource) => newResource.url === currentResource.url,
          )
          if (newResource) {
            if (!hotResource.replace) {
              return null
            }
            actions.push({
              type: "replace",
              url: currentResource.url,
              fn: hotResource.replace,
            })
          }
          if (!hotResource.remove) {
            return null
          }
          actions.push({
            type: "remove",
            url: currentResource.url,
            fn: hotResource.remove,
          })
        }
        for (const newResource of newResources) {
          const hotResource = hotResources[newResource.url]
          if (!hotResource) {
            return null
          }
          const currentResource = currentResources.find(
            (currentResource) => currentResource.url === newResource.url,
          )
          if (currentResource) {
            continue // already handled in previous loop
          }
          if (!hotResource.add) {
            return null
          }
          actions.push({
            type: "add",
            url: newResource.url,
            fn: hotResource.add,
          })
        }

        // if nothing has changed it means it's the worker implementation (the code)
        // that has changed, so we need to reload
        if (actions.length === 0) {
          return null
        }
        return async () => {
          await Promise.all(actions.map((action) => action()))
        }
      }

      const updateDownloadingMessage = document.querySelector(
        "#update_downloading_message",
      )
      const checkForUpdates = async () => {
        const registration = await serviceWorkerAPI.getRegistration()
        if (!registration) {
          return false
        }
        const updateRegistration = await registration.update()
        if (!updateRegistration.installing && !updateRegistration.waiting) {
          console.log(
            "no update found on registration.installing and registration.waiting",
          )
          return false
        }
        return true
      }
      const onUpdateFound = async (newServiceWorker) => {
        console.log(`"updatefound" ${newServiceWorker.scriptURL}`)
        const currentInfo = await currentSwInfoPromise
        const updateInfo = await inspectServiceWorker(newServiceWorker)
        document.querySelector("#update_version").innerHTML = updateInfo.version

        const applyUpdate = createApplyUpdate({ updateInfo, currentInfo })
        const reloadRequired = !applyUpdate

        const checkState = async () => {
          if (newServiceWorker.state === "installing") {
            onUpdateInstalling({
              updateInfo,
              currentInfo,
              reloadRequired,
            })
          }
          if (newServiceWorker.state === "installed") {
            onUpdateWaiting({
              updateInfo,
              currentInfo,
              reloadRequired,
              activate: async () => {
                if (newServiceWorker.state === "installed") {
                  const activatedPromise = new Promise((resolve) => {
                    newServiceWorker.onstatechange = () => {
                      console.log(`statechange to ${newServiceWorker.state}`)
                      if (newServiceWorker.state === "activated") {
                        console.log("resolving")
                        resolve()
                      }
                    }
                  })
                  console.log("update is installed, send skipWaiting")
                  await requestSkipWaiting(newServiceWorker)
                  console.log(
                    "skipWaiting done, wait for worker to be activated",
                  )
                  await activatedPromise
                }
                if (newServiceWorker.state === "activated") {
                  if (serviceWorkerAPI.controller === newServiceWorker) {
                    console.log("update activated and controlling navigator")
                  } else {
                    console.log(
                      "update activated, let it claim to be navigator controller",
                    )
                    const becomesControllerPromise = new Promise((resolve) => {
                      const oncontrollerchange = () => {
                        if (serviceWorkerAPI.controller === newServiceWorker) {
                          serviceWorkerAPI.removeEventListener(
                            "controllerchange",
                            oncontrollerchange,
                          )
                          resolve()
                        }
                      }
                      serviceWorkerAPI.addEventListener(
                        "controllerchange",
                        oncontrollerchange,
                      )
                    })
                    requestClaim(newServiceWorker)
                    await becomesControllerPromise
                  }
                  return
                }
                throw new Error(
                  `unexpected state on service worker update: "${newServiceWorker.state}"`,
                )
              },
            })
          }
          if (newServiceWorker.state === "activated") {
            newServiceWorker.removeEventListener("statechange", checkState)
            if (serviceWorkerAPI.controller === newServiceWorker) {
              console.log("update activated and controlling navigator")
            } else {
              console.log(
                "update activated, let it claim to be navigator controller",
              )
              const becomesControllerPromise = new Promise((resolve) => {
                const oncontrollerchange = () => {
                  if (serviceWorkerAPI.controller === newServiceWorker) {
                    serviceWorkerAPI.removeEventListener(
                      "controllerchange",
                      oncontrollerchange,
                    )
                    resolve()
                  }
                }
                serviceWorkerAPI.addEventListener(
                  "controllerchange",
                  oncontrollerchange,
                )
              })
              requestClaim(newServiceWorker)
              await becomesControllerPromise
            }
            if (applyUpdate) {
              console.log("apply update without reloading")
              await applyUpdate()
            } else {
              console.log("reloading browser")
              // the other tabs should reload
              // how can we achieve this???
              reloadPage()
            }
          }
        }
        checkState()
        newServiceWorker.addEventListener("statechange", checkState)
      }
      const onUpdateInstalling = ({ updateInfo }) => {
        updateDownloadingMessage.style.display = "block"
        updateDownloadingMessage.innerHTML = `Downloading update ${updateInfo.version} ...`
      }
      const onUpdateWaiting = ({ reloadRequired, activate }) => {
        updateDownloadingMessage.style.display = "none"
        const updateByRestartButton = document.querySelector(
          "#update_by_restart_button",
        )
        updateByRestartButton.disabled = !reloadRequired
        updateByRestartButton.onclick = async () => {
          updateByRestartButton.disabled = true
          // idéalement update le message du boutton pendant qu'il est
          // désactivé pour dire ce qu'il se passe (activating, ...)
          await activate()
        }
        const updateNowButton = document.querySelector("#update_now_button")
        updateNowButton.disabled = reloadRequired
        updateNowButton.onclick = async () => {
          updateNowButton.disabled = true
          // idéalement update le message du bouton pendant que apply se produit
          await activate()
        }
      }

      const watchRegistration = (registration) => {
        // setTimeout because of https://github.com/w3c/ServiceWorker/issues/515
        setTimeout(() => {
          registration.onupdatefound = async () => {
            onUpdateFound(registration.installing)
          }
        })
        const { installing, waiting, active } = registration
        const serviceWorker = installing || waiting || active
        serviceWorkerAPI.startMessages()

        currentSwInfoPromise = inspectServiceWorker(serviceWorker)
        currentSwInfoPromise.then((currentinfo) => {
          document.querySelector("#current_version").innerHTML =
            currentinfo.version
        })
        if (installing) {
          console.log(`service worker is installing...`)
          installing.onstatechange = () => {
            console.log(`installing "statechange" to ${installing.state}`)
          }
        } else if (waiting) {
          console.log(`service worker is installed and waiting to activate`)
          waiting.onstatechange = () => {
            console.log(`waiting script "statechange" to ${waiting.state}`)
          }
          if (active) {
            active.onstatechange = () => {
              console.log(`active script "statechange" to ${waiting.state}`)
            }
          }
        } else {
          console.log(`service worker is active`)
          active.onstatechange = () => {
            console.log(`active script "statechange" to ${active.state}`)
          }
        }
      }

      const img = document.querySelector("img")
      const refreshImg = async () => {
        img.src = ""
        const response = await window.fetch("./animal.svg?v=dog")
        const blob = await response.blob()
        const objectUrl = URL.createObjectURL(blob)
        await new Promise((resolve) => setTimeout(resolve, 150))
        img.src = objectUrl
      }

      const hotResources = {
        // "animal.svg": {
        //   update: refreshImg,
        //   prune: () => URL.revokeObjectURL(img.src),
        // },
      }

      let refreshing = false
      const reloadPage = () => {
        if (refreshing) {
          return
        }
        refreshing = true
        window.location.reload()
      }

      const init = async () => {
        const registration = await serviceWorkerAPI.getRegistration()
        if (registration) {
          watchRegistration(registration)
        }
      }
      init()

      const buildDogButton = document.querySelector("#build_dog")
      buildDogButton.onclick = () => {
        fetch("/update_animal_to_dog")
      }
      const buildHorseButton = document.querySelector("#build_horse")
      buildHorseButton.onclick = () => {
        fetch("/update_animal_to_horse")
      }
      const buildCatButton = document.querySelector("#build_cat")
      buildCatButton.onclick = () => {
        fetch("/update_animal_to_cat")
      }

      const registerButton = document.querySelector("#register")
      registerButton.disabled = false
      registerButton.onclick = async () => {
        registerButton.disabled = true
        try {
          const registration = await serviceWorkerAPI.register("./sw.js")
          watchRegistration(registration)
        } finally {
          registerButton.disabled = false
        }
      }

      const updateCheckButton = document.querySelector("#update_check_button")
      updateCheckButton.disabled = false
      updateCheckButton.onclick = async () => {
        updateCheckButton.disabled = true
        try {
          const update = await checkForUpdates()
          if (!update) {
            // eslint-disable-next-line no-alert
            window.alert("there is no update available")
          }
        } finally {
          updateCheckButton.disabled = false
        }
      }

      // in practice there will be no such UI, it's only for dev 99% of the time
      const unregisterButton = document.querySelector("#unregister")
      unregisterButton.disabled = false
      unregisterButton.onclick = async () => {
        unregisterButton.disabled = true
        try {
          const registration = await serviceWorkerAPI.getRegistration()
          if (registration) {
            const unregistered = await registration.unregister()
            if (unregistered) {
              console.log("unregister done")
            } else {
              console.log("unregister failed")
            }
          }
        } finally {
          unregisterButton.disabled = false
        }
      }

      const refreshButton = document.querySelector("#refresh")
      refreshButton.onclick = async () => {
        refreshButton.disabled = true
        try {
          await refreshImg()
        } finally {
          refreshButton.disabled = false
        }
      }
    </script>
  </body>
</html>
