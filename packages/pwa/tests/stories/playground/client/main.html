<!-- 
https://web.dev/service-worker-lifecycle/

comment on fait pour reload les autres tabs?
est ce que un autre tab reçoit aussi le "updatefound"
est ce alors une bonne idée de détecter que c'est un tab en background?
ou alors il veut mieux que ce soit le tab actif qui lui dise quoi faire?
ou alors que un tab inactif juste se reload lorsqu'il devient actif pour éviter ce souci? 
(ça a l'air bien ça)

bon il reste a faire ceci:
- tester déja le cas du autoreload on update
- tester avec plusieurs onglet
- puis remettre hotResources afin de montrer qu'on sait autoreload l'image
et donc pas besoin de reload le browser

Ne pas oublier de tester ce qui se passe si on fait 2 "updatefound"
hot reloadable d'affilé, voir un 3eme
      
-->

<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8" />
    <link rel="icon" href="data:," />
  </head>

  <body>
    <div id="animal_ui">
      <fieldset>
        <legend>Animal image <button id="refresh">refresh</button></legend>
        <img style="display: block" height="200" src="./animal.svg?v=dog" />
      </fieldset>
    </div>
    <div id="service_worker_ui">
      <fieldset>
        <legend>Service worker script</legend>
        <button id="register" disabled>register sw.js</button>
        <button id="unregister" disabled>unregister</button>
        <br />
        <br />
        <button id="update_check_button" disabled>Check for updates</button>
        <div id="update_downloading_message" style="display: none">
          Downloading update...
        </div>
        <button id="update_by_restart_button" disabled>
          Restart to update
        </button>
        <button id="update_now_button" disabled>Apply update</button>
      </fieldset>
    </div>
    <div id="trigger_file_changes">
      <fieldset>
        <legend>Update files</legend>
        <button id="build_dog">Build dog</button>
        <button id="build_horse">Build horse</button>
        <button id="build_cat">Build cat</button>
        <button id="build_sw_script">Build sw script</button>
      </fieldset>
    </div>

    <script>
      const serviceWorkerAPI = window.navigator.serviceWorker

      const postMessageToServiceWorker = (serviceWorker, message) => {
        const { port1, port2 } = new MessageChannel()
        return new Promise((resolve, reject) => {
          port1.onmessage = function (event) {
            if (event.data.status === "rejected") {
              reject(event.data.payload)
            } else {
              resolve(event.data.payload)
            }
          }
          serviceWorker.postMessage(message, [port2])
        })
      }
      // eslint-disable-next-line no-unused-vars
      const postMessageToCurrentServiceWorker = async (message) => {
        const controller = serviceWorkerAPI.controller
        if (controller) {
          return postMessageToServiceWorker(controller, message)
        }
        const registration = await serviceWorkerAPI.getRegistration()
        if (!registration) {
          throw new Error("no service worker registered to communicate with")
        }
        return postMessageToServiceWorker(
          registration.installing ||
            registration.waiting ||
            registration.active,
          message,
        )
      }
      const inspectServiceWorker = async (serviceWorker) => {
        let serviceWorkerResponse
        console.log(`inspect ${serviceWorker.scriptURL}`)
        const inspectPromise = postMessageToServiceWorker(serviceWorker, {
          action: "inspect",
        }).then((info) => {
          console.log(`${serviceWorker.scriptURL} inspect result ->`, info)
          serviceWorkerResponse = info
        })
        let timeout
        let timeoutReached = false
        const timeoutPromise = new Promise((resolve) => {
          timeout = setTimeout(() => {
            timeoutReached = true
            resolve()
          }, 1000)
        })
        await Promise.race([inspectPromise, timeoutPromise])
        clearTimeout(timeout)
        if (timeoutReached) {
          return null
        }
        return serviceWorkerResponse
      }
      const requestSkipWaiting = (serviceWorker) => {
        console.log("send skipWaiting")
        return postMessageToServiceWorker(serviceWorker, {
          action: "skipWaiting",
        })
      }
      const requestClaim = (serviceWorker) => {
        console.log("send claim")
        return postMessageToServiceWorker(serviceWorker, {
          action: "claim",
        })
      }

      let currentSwInfoPromise = null
      const createApplyUpdate = ({ updateInfo, currentInfo }) => {
        const actions = []
        if (!currentInfo || !currentInfo.resources) {
          return null
        }
        if (!updateInfo || !updateInfo.resources) {
          return null
        }
        const currentResources = currentInfo.resources
        const newResources = updateInfo.resources
        for (const currentResource of currentResources) {
          const hotResource = hotResources[currentResource.url]
          if (!hotResource) {
            return null
          }
          const newResource = newResources.find(
            (newResource) => newResource.url === currentResource.url,
          )
          if (newResource) {
            if (!hotResource.replace) {
              return null
            }
            actions.push({
              type: "replace",
              url: currentResource.url,
              fn: hotResource.replace,
            })
          }
          if (!hotResource.remove) {
            return null
          }
          actions.push({
            type: "remove",
            url: currentResource.url,
            fn: hotResource.remove,
          })
        }
        for (const newResource of newResources) {
          const hotResource = hotResources[newResource.url]
          if (!hotResource) {
            return null
          }
          const currentResource = currentResources.find(
            (currentResource) => currentResource.url === newResource.url,
          )
          if (currentResource) {
            continue // already handled in previous loop
          }
          if (!hotResource.add) {
            return null
          }
          actions.push({
            type: "add",
            url: newResource.url,
            fn: hotResource.add,
          })
        }

        // if nothing has changed it means it's the worker implementation (the code)
        // that has changed, so we need to reload
        if (actions.length === 0) {
          return null
        }
        return async () => {
          await Promise.all(actions.map((action) => action()))
        }
      }

      const updateDownloadingMessage = document.querySelector(
        "#update_downloading_message",
      )
      const checkForUpdates = async () => {
        const registration = await serviceWorkerAPI.getRegistration()
        if (!registration) {
          return false
        }
        const updateRegistration = await registration.update()
        if (!updateRegistration.installing && !updateRegistration.waiting) {
          console.log(
            "no update found on registration.installing and registration.waiting",
          )
          return false
        }
        return true
      }
      const onUpdateFound = async (newServiceWorker) => {
        console.log(`"updatefound" ${newServiceWorker.scriptURL}`)
        const currentInfo = await currentSwInfoPromise
        const updateInfo = await inspectServiceWorker(newServiceWorker)
        console.log(updateInfo)
        const applyUpdate = createApplyUpdate({ updateInfo, currentInfo })
        const reloadRequired = !applyUpdate

        if (newServiceWorker.state === "installing") {
          onUpdateInstalling({
            updateInfo,
            currentInfo,
            reloadRequired,
          })
          const installedPromise = new Promise((resolve) => {
            newServiceWorker.onstatechange = () => {
              if (newServiceWorker.state === "installed") {
                resolve()
              }
            }
          })
          await installedPromise
        }
        if (newServiceWorker.state === "installed") {
          onUpdateWaiting({
            updateInfo,
            currentInfo,
            reloadRequired,
            apply: async () => {
              if (newServiceWorker.state === "installed") {
                const activatedPromise = await new Promise((resolve) => {
                  newServiceWorker.onstatechange = () => {
                    console.log(`statechange to ${newServiceWorker.state}`)
                    if (newServiceWorker.state === "activated") {
                      resolve()
                    }
                  }
                })
                await requestSkipWaiting(newServiceWorker)
                console.log("wait for worker to be activated")
                await activatedPromise
              }
              if (newServiceWorker.state === "activated") {
                if (serviceWorkerAPI.controller !== newServiceWorker) {
                  await requestClaim(newServiceWorker)
                }
                if (applyUpdate) {
                  console.log("applying update")
                  await applyUpdate()
                } else {
                  console.log("reloading browser")
                  // the other tabs should reload
                  // how can we achieve this???
                  reloadPage()
                }
              }
              throw new Error(
                `unexpected state on service worker update: "${newServiceWorker.state}"`,
              )
            },
          })
        }
      }
      const onUpdateInstalling = ({ updateInfo }) => {
        updateDownloadingMessage.style.display = "block"
        updateDownloadingMessage.innerHTML = `Downloading update ${updateInfo.version} ...`
      }
      const onUpdateWaiting = ({ reloadRequired, apply }) => {
        updateDownloadingMessage.style.display = "none"
        const updateByRestartButton = document.querySelector(
          "#update_by_restart_button",
        )
        updateByRestartButton.disabled = !reloadRequired
        updateByRestartButton.onclick = async () => {
          updateByRestartButton.disabled = true
          // idéalement update le message du boutton pendant qu'il est
          // désactivé pour dire ce qu'il se passe (activating, ...)
          await apply()
        }
        const updateNowButton = document.querySelector("#update_now_button")
        updateNowButton.disabled = reloadRequired
        updateNowButton.onclick = async () => {
          updateNowButton.disabled = true
          // idéalement update le message du bouton pendant que apply se produit
          await apply()
        }
      }

      const watchRegistration = (registration) => {
        // setTimeout because of https://github.com/w3c/ServiceWorker/issues/515
        setTimeout(() => {
          registration.onupdatefound = async () => {
            onUpdateFound(registration.installing)
          }
        })
        const { installing, waiting, active } = registration
        const serviceWorker = installing || waiting || active
        serviceWorkerAPI.startMessages()

        currentSwInfoPromise = inspectServiceWorker(serviceWorker)
        if (installing) {
          console.log(`service worker is installing...`)
          installing.onstatechange = () => {
            console.log(`installing "statechange" to ${installing.state}`)
          }
        } else if (waiting) {
          console.log(`service worker is installed and waiting to activate`)
          waiting.onstatechange = () => {
            console.log(`waiting script "statechange" to ${waiting.state}`)
          }
          if (active) {
            active.onstatechange = () => {
              console.log(`active script "statechange" to ${waiting.state}`)
            }
          }
        } else {
          console.log(`service worker is active`)
          active.onstatechange = () => {
            console.log(`active script "statechange" to ${active.state}`)
          }
        }
      }

      const img = document.querySelector("img")
      const refreshImg = async () => {
        img.src = ""
        const response = await window.fetch("./animal.svg?v=dog")
        const blob = await response.blob()
        const objectUrl = URL.createObjectURL(blob)
        await new Promise((resolve) => setTimeout(resolve, 150))
        img.src = objectUrl
      }

      const hotResources = {
        // "animal.svg": {
        //   update: refreshImg,
        //   prune: () => URL.revokeObjectURL(img.src),
        // },
      }

      let refreshing = false
      const reloadPage = () => {
        if (refreshing) {
          return
        }
        refreshing = true
        window.location.reload()
      }

      const init = async () => {
        const registration = await serviceWorkerAPI.getRegistration()
        if (registration) {
          watchRegistration(registration)
        }
      }
      init()

      const buildDogButton = document.querySelector("#build_dog")
      buildDogButton.onclick = () => {
        fetch("/update_animal_to_dog")
      }
      const buildHorseButton = document.querySelector("#build_horse")
      buildHorseButton.onclick = () => {
        fetch("/update_animal_to_horse")
      }
      const buildCatButton = document.querySelector("#build_cat")
      buildCatButton.onclick = () => {
        fetch("/update_animal_to_cat")
      }

      const registerButton = document.querySelector("#register")
      registerButton.disabled = false
      registerButton.onclick = async () => {
        registerButton.disabled = true
        try {
          const registration = await serviceWorkerAPI.register("./sw.js")
          watchRegistration(registration)
        } finally {
          registerButton.disabled = false
        }
      }

      const updateCheckButton = document.querySelector("#update_check_button")
      updateCheckButton.disabled = false
      updateCheckButton.onclick = async () => {
        updateCheckButton.disabled = true
        try {
          const update = await checkForUpdates()
          if (!update) {
            // eslint-disable-next-line no-alert
            window.alert("there is no update available")
          }
        } finally {
          updateCheckButton.disabled = false
        }
      }

      // in practice there will be no such UI, it's only for dev 99% of the time
      const unregisterButton = document.querySelector("#unregister")
      unregisterButton.disabled = false
      unregisterButton.onclick = async () => {
        unregisterButton.disabled = true
        try {
          const registration = await serviceWorkerAPI.getRegistration()
          if (registration) {
            const unregistered = await registration.unregister()
            if (unregistered) {
              console.log("unregister done")
            } else {
              console.log("unregister failed")
            }
          }
        } finally {
          unregisterButton.disabled = false
        }
      }

      const refreshButton = document.querySelector("#refresh")
      refreshButton.onclick = async () => {
        refreshButton.disabled = true
        try {
          await refreshImg()
        } finally {
          refreshButton.disabled = false
        }
      }
    </script>
  </body>
</html>
