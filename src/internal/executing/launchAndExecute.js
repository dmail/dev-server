import { createLogger, createDetailedMessage } from "@jsenv/logger"

import { Abort, createOperation } from "@jsenv/core/src/abort/main.js"
import { promiseTrackRace } from "../promise_track_race.js"
import { composeIstanbulCoverages } from "./coverage/composeIstanbulCoverages.js"

const TIMING_BEFORE_EXECUTION = "before-execution"
const TIMING_DURING_EXECUTION = "during-execution"
const TIMING_AFTER_EXECUTION = "after-execution"

export const launchAndExecute = async ({
  abortSignal,
  launchAndExecuteLogLevel,

  runtime,
  runtimeParams,
  executeParams,

  allocatedMs,
  measureDuration = false,
  mirrorConsole = false,
  captureConsole = false, // rename collectConsole ?
  collectRuntimeName = false,
  collectRuntimeVersion = false,
  inheritCoverage = false,
  collectCoverage = false,
  measurePerformance,
  collectPerformance = false,

  // stopAfterExecute false by default because you want to keep browser alive
  // or nodejs process
  // however unit test will pass true because they want to move on
  stopAfterExecute = false,
  stopAfterExecuteReason = "stop after execute",
  // when launch returns { disconnected, gracefulStop, stop }
  // the launched runtime have that amount of ms for disconnected to resolve
  // before we call stop
  gracefulStopAllocatedMs = 4000,

  runtimeConsoleCallback = () => {},
  runtimeStartedCallback = () => {},
  runtimeStoppedCallback = () => {},
  runtimeErrorAfterExecutionCallback = (error) => {
    // by default throw on error after execution
    throw error
  },
  runtimeDisconnectCallback = () => {},

  coverageV8MergeConflictIsExpected,
} = {}) => {
  const logger = createLogger({ logLevel: launchAndExecuteLogLevel })

  if (typeof runtime !== "object") {
    throw new TypeError(`runtime must be an object, got ${runtime}`)
  }
  if (typeof runtime.launch !== "function") {
    throw new TypeError(
      `runtime.launch must be a function, got ${runtime.launch}`,
    )
  }

  const launchAndExecuteOperation = createOperation({
    abortSignal,
  })

  let executionResultTransformer = (executionResult) => executionResult

  if (measureDuration) {
    const startMs = Date.now()
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        const endMs = Date.now()
        executionResult.startMs = startMs
        executionResult.endMs = endMs
        return executionResult
      },
    )
  }

  if (mirrorConsole) {
    runtimeConsoleCallback = composeCallback(
      runtimeConsoleCallback,
      ({ type, text }) => {
        if (type === "error") {
          process.stderr.write(text)
        } else {
          process.stdout.write(text)
        }
      },
    )
  }

  if (captureConsole) {
    const consoleCalls = []
    runtimeConsoleCallback = composeCallback(
      runtimeConsoleCallback,
      ({ type, text }) => {
        consoleCalls.push({ type, text })
      },
    )
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        executionResult.consoleCalls = consoleCalls
        return executionResult
      },
    )
  }

  if (collectRuntimeName) {
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        executionResult.runtimeName = runtime.name
        return executionResult
      },
    )
  }

  if (collectRuntimeVersion) {
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        executionResult.runtimeVersion = runtime.version
        return executionResult
      },
    )
  }

  if (
    inheritCoverage &&
    // NODE_V8_COVERAGE is doing the coverage propagation for us
    !process.env.NODE_V8_COVERAGE
  ) {
    const collectCoverageSaved = collectCoverage
    collectCoverage = true
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        const { coverage, ...rest } = executionResult
        // ensure the coverage of the executed file is taken into account
        global.__coverage__ = composeIstanbulCoverages([
          global.__coverage__ || {},
          coverage || {},
        ])
        if (collectCoverageSaved) {
          return executionResult
        }
        return rest
      },
    )
  }

  // indirectCoverage is a feature making possible to collect
  // coverage generated by executing a node process which executes
  // a browser. The coverage coming the browser executionwould be lost
  // if not propagated somehow.
  // This is possible if the node process collect the browser coverage
  // and write it into global.__indirectCoverage__
  // This is used by jsenv during tests execution
  if (collectCoverage) {
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        const { coverage, indirectCoverage } = executionResult
        if (indirectCoverage) {
          executionResult.coverage = composeIstanbulCoverages(
            [coverage, indirectCoverage],
            {
              coverageV8MergeConflictIsExpected,
            },
          )
        }
        return executionResult
      },
    )
  } else {
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        // as collectCoverage is disabled
        // executionResult.coverage is undefined or {}
        // we delete it just to have a cleaner object
        delete executionResult.coverage
        return executionResult
      },
    )
  }

  const hasAllocatedMs =
    typeof allocatedMs === "number" && allocatedMs !== Infinity
  const timeoutAbortController = new AbortController()
  if (hasAllocatedMs) {
    const timeoutId = setTimeout(
      () => {
        timeoutAbortController.abort()
      },
      // FIXME: if allocatedMs is veryyyyyy big
      // setTimeout may be called immediatly
      // in that case we should just throw that the number is too big
      allocatedMs,
    )
    launchAndExecuteOperation.abortSignal = Abort.composeTwoAbortSignals(
      launchAndExecuteOperation.abortSignal,
      timeoutAbortController.signal,
    )
    launchAndExecuteOperation.cleaner.addCallback(() => {
      clearTimeout(timeoutId)
    })

    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      (executionResult) => {
        clearTimeout(timeoutId)
        return executionResult
      },
    )
  }

  try {
    const runtimeLabel = `${runtime.name}/${runtime.version}`
    logger.debug(`launch ${runtimeLabel} to execute something in it`)

    Abort.throwIfAborted(launchAndExecuteOperation.abortSignal)
    const launchReturnValue = await runtime.launch({
      logger,
      abortSignal: launchAndExecuteOperation.abortSignal,
      stopAfterExecute,
      measurePerformance,
      collectPerformance,
      ...runtimeParams,
    })
    validateLaunchReturnValue(launchReturnValue)
    launchAndExecuteOperation.cleanup.addCallback(async (reason) => {
      const { stoppedGracefully } = await stopRuntime({
        logger,
        runtimeLabel,
        launchReturnValue,
        gracefulStopAllocatedMs,
        reason,
      })
      runtimeStoppedCallback({ stoppedGracefully })
    })

    logger.debug(createDetailedMessage(`${runtimeLabel}: runtime launched`))
    runtimeStartedCallback()

    logger.debug(`${runtimeLabel}: start execution`)
    const {
      execute,
      disconnected,
      registerErrorCallback = () => {},
      registerConsoleCallback = () => {},
      finalizeExecutionResult = (executionResult) => executionResult,
    } = launchReturnValue
    executionResultTransformer = composeTransformer(
      executionResultTransformer,
      finalizeExecutionResult,
    )
    registerConsoleCallback(runtimeConsoleCallback)

    let timing = TIMING_BEFORE_EXECUTION
    disconnected.then(() => {
      logger.debug(`${runtimeLabel}: runtime disconnected ${timing}`)
      runtimeDisconnectCallback({ timing })
    })
    const executed = execute(executeParams)
    timing = TIMING_DURING_EXECUTION

    Abort.throwIfAborted(launchAndExecuteOperation.abortSignal)
    const raceResult = await promiseTrackRace([disconnected, executed])
    timing = TIMING_AFTER_EXECUTION

    if (raceResult.winner === disconnected) {
      return executionResultTransformer(createDisconnectedExecutionResult())
    }

    if (stopAfterExecute) {
      // if there is an error while cleaning (stopping the runtime)
      // the execution is considered as failed
      try {
        await launchAndExecuteOperation.cleaner.clean(stopAfterExecuteReason)
      } catch (e) {
        return executionResultTransformer(
          createErroredExecutionResult({
            error: e,
          }),
        )
      }
    } else {
      // when the process is still alive
      // we want to catch error to notify runtimeErrorAfterExecutionCallback
      // and throw that error by default
      registerErrorCallback((error) => {
        runtimeErrorAfterExecutionCallback(error)
      })
    }

    const executionResult = raceResult.value
    const { status } = executionResult

    if (status === "errored") {
      // debug log level because this error happens during execution
      // there is no need to log it.
      // the code will know the execution errored because it receives
      // an errored execution result
      logger.debug(
        createDetailedMessage(`error ${TIMING_DURING_EXECUTION}`, {
          ["error stack"]: executionResult.error.stack,
          ["execute params"]: JSON.stringify(executeParams, null, "  "),
          ["runtime"]: runtime,
        }),
      )
      return executionResultTransformer(
        createErroredExecutionResult(executionResult),
      )
    }

    logger.debug(`${runtimeLabel}: execution completed`)
    return executionResultTransformer(
      createCompletedExecutionResult(executionResult),
    )
  } catch (e) {
    if (e.name === "AbortError") {
      if (timeoutAbortController.signal.aborted) {
        const executionResult = createTimedoutExecutionResult()
        return executionResultTransformer(executionResult)
      }
      const executionResult = createAbortedExecutionResult()
      return executionResultTransformer(executionResult)
    }
    throw e
  }
}

const stopRuntime = async ({
  logger,
  runtimeLabel,
  launchReturnValue,
  gracefulStopAllocatedMs,
  reason,
}) => {
  const { gracefulStop, stop } = launchReturnValue

  // external code can cancel using cancellationToken at any time.
  // it is important to keep the code inside this stop function because once cancelled
  // all code after the operation won't execute because it will be rejected with
  // the cancellation error

  let stoppedGracefully

  if (gracefulStop && gracefulStopAllocatedMs) {
    logger.debug(`${runtimeLabel}: runtime.gracefulStop() because ${reason}`)

    const gracefulStopPromise = (async () => {
      await gracefulStop({ reason })
      return true
    })()

    const stopPromise = (async () => {
      stoppedGracefully = await new Promise(async (resolve) => {
        const timeoutId = setTimeout(() => {
          resolve(false)
        }, gracefulStopAllocatedMs)
        try {
          await gracefulStopPromise
          resolve(true)
        } finally {
          clearTimeout(timeoutId)
        }
      })
      if (stoppedGracefully) {
        return stoppedGracefully
      }

      logger.debug(
        `${runtimeLabel}: runtime.stop() because gracefulStop still pending after ${gracefulStopAllocatedMs}ms`,
      )
      await stop({ reason, gracefulFailed: true })
      return false
    })()

    stoppedGracefully = await Promise.race([gracefulStopPromise, stopPromise])
  } else {
    await stop({ reason, gracefulFailed: false })
    stoppedGracefully = false
  }

  logger.debug(
    `${runtimeLabel}: runtime stopped${stoppedGracefully ? " gracefully" : ""}`,
  )

  return {
    stoppedGracefully,
  }
}

const createAbortedExecutionResult = () => {
  return {
    status: "aborted",
  }
}

const createTimedoutExecutionResult = () => {
  return {
    status: "timedout",
  }
}

const createDisconnectedExecutionResult = () => {
  return {
    status: "disconnected",
  }
}

const createErroredExecutionResult = (executionResult) => {
  return {
    ...executionResult,
    status: "errored",
  }
}

const createCompletedExecutionResult = (executionResult) => {
  return {
    ...executionResult,
    status: "completed",
    namespace: normalizeNamespace(executionResult.namespace),
  }
}

const normalizeNamespace = (namespace) => {
  if (typeof namespace !== "object") return namespace
  if (namespace instanceof Promise) return namespace
  const normalized = {}
  // remove "__esModule" or Symbol.toStringTag from namespace object
  Object.keys(namespace).forEach((key) => {
    normalized[key] = namespace[key]
  })
  return normalized
}

const composeCallback = (previousCallback, callback) => {
  return (...args) => {
    previousCallback(...args)
    return callback(...args)
  }
}

const composeTransformer = (previousTransformer, transformer) => {
  return (value) => {
    const transformedValue = previousTransformer(value)
    return transformer(transformedValue)
  }
}

const validateLaunchReturnValue = (launchReturnValue) => {
  if (launchReturnValue === null) {
    throw new Error(`launch must return an object, got null`)
  }

  if (typeof launchReturnValue !== "object") {
    throw new Error(`launch must return an object, got ${launchReturnValue}`)
  }

  const { execute } = launchReturnValue
  if (typeof execute !== "function") {
    throw new Error(`launch must return an execute function, got ${execute}`)
  }

  const { disconnected } = launchReturnValue
  if (!disconnected || typeof disconnected.then !== "function") {
    throw new Error(`launch must return a disconnected promise, got ${execute}`)
  }
}
