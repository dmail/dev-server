import fs from "fs"
import path from "path"
import sourceMapSupport from "source-map-support"
import { createCancellationSource } from "@dmail/cancellation"
import { uneval } from "@dmail/uneval"
import { platform } from "../platform/node/nodePlatform.js"
import { registerProcessInterruptCallback } from "../process-signal/index.js"
import { replaceSourceMappingURL } from "../replaceSourceMappingURL.js"

const sendToParent = (type, data) => {
  // process.send algorithm does not send non enumerable values
  // because it works with JSON.stringify I guess so use uneval
  const source = uneval(data)

  process.send({
    type,
    data: source,
  })
}

const exceptionToObject = (exception) => {
  if (exception && exception instanceof Error) {
    const object = {}
    Object.getOwnPropertyNames(exception).forEach((name) => {
      object[name] = exception[name]
    })
    return object
  }

  return {
    message: exception,
  }
}

process.on("uncaughtException", (valueThrowed) => {
  // console.log("exception")
  // debugger
  sendToParent("error", exceptionToObject(valueThrowed))
  // once errored, the child must die
  process.exit(1)
})

process.on("unhandledRejection", (valueRejected) => {
  // console.log("rejection")
  // debugger
  sendToParent("error", exceptionToObject(valueRejected))
  // once errored, the child must die
  process.exit(1)
})

const listenParentOnce = (type, callback) => {
  const listener = (event) => {
    if (event.type === type) {
      // commenting line below keep this process alive
      removeListener()
      callback(eval(`(${event.data})`))
    }
  }

  const removeListener = () => {
    process.removeListener("message", listener)
  }

  process.on("message", listener)
  return removeListener
}

const { token, cancel } = createCancellationSource()

token.register(
  registerProcessInterruptCallback(() => {
    // cancel will remove listener to process.on('message')
    // which is sufficient to let child process die
    // assuming nothing else keeps it alive
    cancel("process interrupt")

    // if something keeps it alive the process won't die
    // but this is the responsability of the code
    // to properly cancel stuff on 'SIGINT'
    // If code does not do that, a process forced exit
    // like process.exit() or child.kill() from parent
    // will ensure process dies
  }),
)

process.on("SIGINT", () => {
  console.log("sigint")
  // cancel will remove listener to process.on('message')
  // which is sufficient to let child process die
  // assuming nothing else keeps it alive
  cancel("process interrupt").then(() => {
    if (process.listeners("SIGINT").length === 1) {
      // ensure child exits in case some code forgot
      // to register 'SIGINT' and keeps process alive
      process.exit(0)
    }
  })
})

token.register(
  listenParentOnce("execute", async ({ localRoot, remoteRoot, compileInto, file, options }) => {
    /*
    sourcemap generated by compil server are like that:
    {
      sources: [
        '/src/file.js'
      ]
    }

    to have proper file path it should either be
    {
      sources: [
        'Users/src/file.js'
      ]
    }

    or specify a sourceRoot like
    {
      sourceRoot: 'Users',
      sources: [
        '/src/file.js'
      ]
    }

    but it would certainly break sourcemap inside vscode or chrome
    to fix this I changed the sourcemap readed by source-map-support
    to ensure sources are absolute.
    See the following issue which talk about same problem
    // https://github.com/evanw/node-source-map-support/issues/120

    It works for now but nust be tested on many use case
    i'm pretty sure it would fail on file inside node_modules for instance
    */
    sourceMapSupport.install({
      retrieveSourceMap: (source) => {
        let content
        try {
          content = fs.readFileSync(source, "utf8")
        } catch (e) {
          return null
        }

        let sourceMappingURL
        replaceSourceMappingURL(content, (value) => {
          sourceMappingURL = value
        })
        const sourceMapFile = path.resolve(path.dirname(source), sourceMappingURL)
        const sourceMapContent = fs.readFileSync(sourceMapFile, "utf8")
        const sourceMap = JSON.parse(sourceMapContent)
        const absoluteSourceMap = {
          ...sourceMap,
          sources: sourceMap.sources.map((source) => `${localRoot}${source}`),
        }

        return {
          url: source,
          map: absoluteSourceMap,
        }
      },
    })

    platform.setup({
      localRoot,
      remoteRoot,
      compileInto,
    })
    platform.importFile(file, options).then(
      (value) => {
        sendToParent("execute-result", { failed: false, value })
      },
      (error) => {
        sendToParent("execute-result", { failed: true, value: error })
      },
    )
  }),
)
