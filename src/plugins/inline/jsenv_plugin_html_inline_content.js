import { generateInlineContentUrl } from "@jsenv/urls"
import {
  parseHtmlString,
  stringifyHtmlAst,
  visitHtmlNodes,
  getHtmlNodeText,
  getHtmlNodePosition,
  analyzeScriptNode,
  setHtmlNodeAttributes,
  setHtmlNodeText,
  getHtmlNodeAttribute,
} from "@jsenv/ast"
import { CONTENT_TYPE } from "@jsenv/utils/src/content_type/content_type.js"

export const jsenvPluginHtmlInlineContent = ({ analyzeConvertedScripts }) => {
  return {
    name: "jsenv:html_inline_content",
    appliesDuring: "*",
    transformUrlContent: {
      html: async (urlInfo, context) => {
        const htmlAst = parseHtmlString(urlInfo.content)
        const actions = []
        visitHtmlNodes(htmlAst, {
          style: (styleNode) => {
            const styleNodeText = getHtmlNodeText(styleNode)
            if (!styleNodeText) {
              return
            }
            actions.push(async () => {
              const { line, column, lineEnd, columnEnd, isOriginal } =
                getHtmlNodePosition(styleNode, {
                  preferOriginal: true,
                })
              const inlineStyleUrl = generateInlineContentUrl({
                url: urlInfo.url,
                extension: ".css",
                line,
                column,
                lineEnd,
                columnEnd,
              })
              const [inlineStyleReference, inlineStyleUrlInfo] =
                context.referenceUtils.foundInline({
                  node: styleNode,
                  type: "link_href",
                  expectedType: "css",
                  isOriginalPosition: isOriginal,
                  // we remove 1 to the line because imagine the following html:
                  // <style>body { color: red; }</style>
                  // -> content starts same line as <style>
                  specifierLine: line - 1,
                  specifierColumn: column,
                  specifier: inlineStyleUrl,
                  contentType: "text/css",
                  content: styleNodeText,
                })
              await context.cook(inlineStyleUrlInfo, {
                reference: inlineStyleReference,
              })
              setHtmlNodeText(styleNode, inlineStyleUrlInfo.content)
              setHtmlNodeAttributes(styleNode, {
                "jsenv-plugin-owner": "jsenv:html_inline_content",
                "jsenv-plugin-action": "content_cooked",
              })
            })
          },
          script: (scriptNode) => {
            const scriptNodeText = getHtmlNodeText(scriptNode)
            if (!scriptNodeText) {
              return
            }
            // If the inline script was already handled by an other plugin, ignore it
            // - we want to preserve inline scripts generated by html supervisor during dev
            // - we want to avoid cooking twice a script during build
            const jsenvPluginOwner = getHtmlNodeAttribute(
              scriptNode,
              "jsenv-plugin-owner",
            )
            if (
              jsenvPluginOwner === "jsenv:as_js_classic_html" &&
              !analyzeConvertedScripts
            ) {
              return
            }
            if (jsenvPluginOwner === "jsenv:supervisor") {
              return
            }
            actions.push(async () => {
              const { type, contentType, extension } =
                analyzeScriptNode(scriptNode)
              const { line, column, lineEnd, columnEnd, isOriginal } =
                getHtmlNodePosition(scriptNode, {
                  preferOriginal: true,
                })
              let inlineScriptUrl = generateInlineContentUrl({
                url: urlInfo.url,
                extension:
                  extension || CONTENT_TYPE.asFileExtension(contentType),
                line,
                column,
                lineEnd,
                columnEnd,
              })
              const [inlineScriptReference, inlineScriptUrlInfo] =
                context.referenceUtils.foundInline({
                  node: scriptNode,
                  type: "script_src",
                  expectedType: type,
                  // we remove 1 to the line because imagine the following html:
                  // <script>console.log('ok')</script>
                  // -> content starts same line as <script>
                  specifierLine: line - 1,
                  specifierColumn: column,
                  isOriginalPosition: isOriginal,
                  specifier: inlineScriptUrl,
                  contentType,
                  content: scriptNodeText,
                })
              await context.cook(inlineScriptUrlInfo, {
                reference: inlineScriptReference,
              })
              setHtmlNodeText(scriptNode, inlineScriptUrlInfo.content)
              setHtmlNodeAttributes(scriptNode, {
                "jsenv-plugin-owner": "jsenv:html_inline_content",
                "jsenv-plugin-action": "content_cooked",
                ...(extension
                  ? { type: type === "js_module" ? "module" : undefined }
                  : {}),
              })
            })
          },
        })
        if (actions.length === 0) {
          return null
        }
        await Promise.all(actions.map((action) => action()))
        const htmlModified = stringifyHtmlAst(htmlAst)
        return {
          content: htmlModified,
        }
      },
    },
  }
}
