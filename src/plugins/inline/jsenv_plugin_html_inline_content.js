import { generateInlineContentUrl } from "@jsenv/urls"
import {
  parseHtmlString,
  stringifyHtmlAst,
  visitHtmlNodes,
  getHtmlNodeText,
  getHtmlNodePosition,
  analyzeScriptNode,
  setHtmlNodeAttributes,
  setHtmlNodeText,
  getHtmlNodeAttribute,
} from "@jsenv/ast"
import { CONTENT_TYPE } from "@jsenv/utils/src/content_type/content_type.js"

export const jsenvPluginHtmlInlineContent = ({ analyzeConvertedScripts }) => {
  return {
    name: "jsenv:html_inline_content",
    appliesDuring: "*",
    transformUrlContent: {
      html: async (urlInfo, context) => {
        const htmlAst = parseHtmlString(urlInfo.content)
        const actions = []
        const handleInlineStyle = (node) => {
          const htmlNodeText = getHtmlNodeText(node)
          if (!htmlNodeText) {
            return
          }
          actions.push(async () => {
            const { line, column, lineEnd, columnEnd, isOriginal } =
              getHtmlNodePosition(node, {
                preferOriginal: true,
              })
            const inlineStyleUrl = generateInlineContentUrl({
              url: urlInfo.url,
              extension: ".css",
              line,
              column,
              lineEnd,
              columnEnd,
            })
            const [inlineStyleReference, inlineStyleUrlInfo] =
              context.referenceUtils.foundInline({
                type: "link_href",
                expectedType: "css",
                isOriginalPosition: isOriginal,
                // we remove 1 to the line because imagine the following html:
                // <style>body { color: red; }</style>
                // -> content starts same line as <style>
                specifierLine: line - 1,
                specifierColumn: column,
                specifier: inlineStyleUrl,
                contentType: "text/css",
                content: htmlNodeText,
              })
            await context.cook(inlineStyleUrlInfo, {
              reference: inlineStyleReference,
            })
            setHtmlNodeText(node, inlineStyleUrlInfo.content)
            setHtmlNodeAttributes(node, {
              generatedBy: "jsenv:html_inline_content",
            })
          })
        }
        const handleInlineScript = (node) => {
          const htmlNodeText = getHtmlNodeText(node)
          if (!htmlNodeText) {
            return
          }
          // If the inline script was already handled by an other plugin, ignore it
          // - we want to preserve inline scripts generated by html supervisor during dev
          // - we want to avoid cooking twice a script during build
          const generatedBy = getHtmlNodeAttribute(node, "generated-by")
          if (
            generatedBy === "jsenv:as_js_classic_html" &&
            !analyzeConvertedScripts
          ) {
            return
          }
          if (generatedBy === "jsenv:html_supervisor") {
            return
          }
          actions.push(async () => {
            const scriptCategory = analyzeScriptNode(node)
            const { line, column, lineEnd, columnEnd, isOriginal } =
              getHtmlNodePosition(node, {
                preferOriginal: true,
              })
            // from MDN about [type] attribute:
            // "Any other value: The embedded content is treated as a data block
            // which won't be processed by the browser. Developers must use a valid MIME type
            // that is not a JavaScript MIME type to denote data blocks.
            // The src attribute will be ignored."
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type
            const isJs =
              scriptCategory === "classic" || scriptCategory === "module"
            const isImportmap = scriptCategory === "importmap"
            const contentType = isJs
              ? "text/javascript"
              : isImportmap
              ? "application/importmap+json"
              : scriptCategory

            let inlineScriptUrl = generateInlineContentUrl({
              url: urlInfo.url,
              extension: CONTENT_TYPE.asFileExtension(contentType),
              line,
              column,
              lineEnd,
              columnEnd,
            })
            const [inlineScriptReference, inlineScriptUrlInfo] =
              context.referenceUtils.foundInline({
                node,
                type: "script_src",
                expectedType: {
                  classic: "js_classic",
                  module: "js_module",
                  importmap: "importmap",
                }[scriptCategory],
                // we remove 1 to the line because imagine the following html:
                // <script>console.log('ok')</script>
                // -> content starts same line as <script>
                specifierLine: line - 1,
                specifierColumn: column,
                isOriginalPosition: isOriginal,
                specifier: inlineScriptUrl,
                contentType,
                content: htmlNodeText,
              })

            await context.cook(inlineScriptUrlInfo, {
              reference: inlineScriptReference,
            })
            setHtmlNodeText(node, inlineScriptUrlInfo.content)
            setHtmlNodeAttributes(node, {
              generatedBy: "jsenv:html_inline_content",
            })
          })
        }
        visitHtmlNodes(htmlAst, {
          style: (node) => {
            handleInlineStyle(node)
          },
          script: (node) => {
            handleInlineScript(node)
          },
        })
        if (actions.length === 0) {
          return null
        }
        await Promise.all(actions.map((action) => action()))
        const htmlModified = stringifyHtmlAst(htmlAst)
        return {
          content: htmlModified,
        }
      },
    },
  }
}
