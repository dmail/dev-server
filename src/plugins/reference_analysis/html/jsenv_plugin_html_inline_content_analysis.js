/*
 * This plugin ensure content inlined inside HTML is cooked (inline <script> for instance)
 * For <script hot-accept> the script content will be moved to a virtual file
 * to enable hot reloading
 */

import { generateInlineContentUrl } from "@jsenv/urls";
import {
  parseHtmlString,
  stringifyHtmlAst,
  visitHtmlNodes,
  getHtmlNodeText,
  getHtmlNodePosition,
  analyzeScriptNode,
  setHtmlNodeAttributes,
  setHtmlNodeText,
  removeHtmlNodeText,
  getHtmlNodeAttribute,
} from "@jsenv/ast";
import { CONTENT_TYPE } from "@jsenv/utils/src/content_type/content_type.js";

export const jsenvPluginHtmlInlineContentAnalysis = ({
  inlineConvertedScript,
}) => {
  const cookInlineContent = async ({
    context,
    inlineContentUrlInfo,
    inlineContentReference,
  }) => {
    try {
      await context.cook(inlineContentUrlInfo, {
        reference: inlineContentReference,
      });
    } catch (e) {
      if (e.code === "PARSE_ERROR") {
        // When something like <style> or <script> contains syntax error
        // the HTML in itself it still valid
        // keep the syntax error and continue with the HTML
        const messageStart =
          inlineContentUrlInfo.type === "css"
            ? `Syntax error on css declared inside <style>`
            : `Syntax error on js declared inside <script>`;

        context.logger.error(`${messageStart}: ${e.cause.reasonCode}
${e.traceMessage}`);
      } else {
        throw e;
      }
    }
  };

  return {
    name: "jsenv:html_inline_content_analysis",
    appliesDuring: "*",
    transformUrlContent: {
      html: async (urlInfo, context) => {
        const htmlAst = parseHtmlString(urlInfo.content);
        const mutations = [];
        const actions = [];
        visitHtmlNodes(htmlAst, {
          style: (styleNode) => {
            const styleNodeText = getHtmlNodeText(styleNode);
            if (!styleNodeText) {
              return;
            }
            const { line, column, lineEnd, columnEnd, isOriginal } =
              getHtmlNodePosition(styleNode, {
                preferOriginal: true,
              });
            const inlineStyleUrl = generateInlineContentUrl({
              url: urlInfo.url,
              extension: ".css",
              line,
              column,
              lineEnd,
              columnEnd,
            });
            const debug =
              getHtmlNodeAttribute(styleNode, "jsenv-debug") !== undefined;
            const [inlineStyleReference, inlineStyleUrlInfo] =
              context.referenceUtils.foundInline({
                node: styleNode,
                type: "style",
                expectedType: "css",
                isOriginalPosition: isOriginal,
                // we remove 1 to the line because imagine the following html:
                // <style>body { color: red; }</style>
                // -> content starts same line as <style>
                specifierLine: line - 1,
                specifierColumn: column,
                specifier: inlineStyleUrl,
                contentType: "text/css",
                content: styleNodeText,
                debug,
              });
            actions.push(async () => {
              await cookInlineContent({
                context,
                inlineContentUrlInfo: inlineStyleUrlInfo,
                inlineContentReference: inlineStyleReference,
              });
            });
            mutations.push(() => {
              setHtmlNodeText(styleNode, inlineStyleUrlInfo.content, {
                indentation: false, // indentation would decrease strack trace precision
              });
              setHtmlNodeAttributes(styleNode, {
                "jsenv-cooked-by": "jsenv:html_inline_content_analysis",
              });
            });
          },
          script: (scriptNode) => {
            const scriptNodeText = getHtmlNodeText(scriptNode);
            if (!scriptNodeText) {
              return;
            }
            // If the inline script was already handled by an other plugin, ignore it
            // - we want to preserve inline scripts generated by html supervisor during dev
            // - we want to avoid cooking twice a script during build
            if (
              !inlineConvertedScript &&
              getHtmlNodeAttribute(scriptNode, "jsenv-injected-by") ===
                "jsenv:js_module_fallback"
            ) {
              return;
            }

            const hotAccept =
              getHtmlNodeAttribute(scriptNode, "hot-accept") !== undefined;
            const { type, contentType, extension } =
              analyzeScriptNode(scriptNode);
            const { line, column, lineEnd, columnEnd, isOriginal } =
              getHtmlNodePosition(scriptNode, {
                preferOriginal: true,
              });
            let inlineScriptUrl = generateInlineContentUrl({
              url: urlInfo.url,
              extension: extension || CONTENT_TYPE.asFileExtension(contentType),
              line,
              column,
              lineEnd,
              columnEnd,
            });
            const debug =
              getHtmlNodeAttribute(scriptNode, "jsenv-debug") !== undefined;
            const [inlineScriptReference, inlineScriptUrlInfo] =
              context.referenceUtils.foundInline({
                node: scriptNode,
                type: "script",
                expectedType: type,
                // we remove 1 to the line because imagine the following html:
                // <script>console.log('ok')</script>
                // -> content starts same line as <script>
                specifierLine: line - 1,
                specifierColumn: column,
                isOriginalPosition: isOriginal,
                specifier: inlineScriptUrl,
                contentType,
                content: scriptNodeText,
                debug,
              });
            actions.push(async () => {
              await cookInlineContent({
                context,
                inlineContentUrlInfo: inlineScriptUrlInfo,
                inlineContentReference: inlineScriptReference,
              });
              mutations.push(() => {
                const attributes = {
                  "jsenv-cooked-by": "jsenv:html_inline_content_analysis",
                  // 1. <script type="jsx"> becomes <script>
                  // 2. <script type="module/jsx"> becomes <script type="module">
                  ...(extension
                    ? { type: type === "js_module" ? "module" : undefined }
                    : {}),
                };
                if (hotAccept) {
                  removeHtmlNodeText(scriptNode);
                  setHtmlNodeAttributes(scriptNode, {
                    ...attributes,
                  });
                } else {
                  setHtmlNodeText(scriptNode, inlineScriptUrlInfo.content, {
                    indentation: false, // indentation would decrease stack trace precision
                  });
                  setHtmlNodeAttributes(scriptNode, {
                    ...attributes,
                  });
                }
              });
            });
          },
        });
        if (actions.length > 0) {
          await Promise.all(actions.map((action) => action()));
        }
        if (mutations.length === 0) {
          return null;
        }
        mutations.forEach((mutation) => mutation());
        const htmlModified = stringifyHtmlAst(htmlAst);
        return htmlModified;
      },
    },
  };
};
