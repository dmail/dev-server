# Jsenv service worker

Jsenv service worker goal is to make the website capable to work offline.

# Presentation

Here is an high level overview of what happens from the very first visit of a user to the moment you update your website and user gets the updated version of it.

## 1) User first visit

- Some code inside that page calls `navigator.serviceWorker.register("./jsenv-sw.js")`.
- Browser fetch/parse/execute `jsenv-sw.js` and its imported scripts (`./jsenv-sw.config.js` + `./jsenv-sw.build_urls.js`). Browser trigger `install` event on `jsenv-sw.js`.
- `jsenv-sw.js` fetch all urls declared in `config.urlsToCacheOnInstall` and puts them into browser cache. It puts them info a cache named after `config.cacheName`. See https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open. These url will be cached as long as this service worker lives.
- Browser trigger `activate` on `jsenv-sw.js`

At this point service worker does not control the page. And **it's expected**. The intent of this service worker is that service worker will handle networks for the next visit. For that next visit, page loads instantly and could work offline.

> We could use `skipWaiting` or `clients.claim()` to allow service worker to take control of the network requests as soon as it is activated, but it not the point of this service worker as explained in the text below.

> Controlling page as soon as possible allow service worker to be aware of eventual request matching `config.shouldCacheRequest` and not in `config.urlsToCacheOnInstall`. But service worker would have missed most of them already as it happens in parallel to the user visiting the page. I prefer to see it like this: a service worker control a page from the very beginning or not at all. It's way simpler to reason about, predict and test.

## 2) User second visit

- Browser is now "controlled" by the service worker. Most network requests will be intercepted and served from cache.
- All request matching `config.shouldCacheRequest` will be served from cache if possible. If the url is not in cache (not in `config.urlsToCacheOnInstall`) it is fetched from network and put into cache. As a result page loads instantly without (or few depending on `config.urlsToCacheOnInstall`) requests to the network.

> It is theorically possible to generate `config.urlsToCacheOnInstall` automatically. We could start a headless browser and communicate to the service worker to start collecting urls, then start loading the site in an iframe and tell him when to stop when something happens in that iframe (like load event, or user reach a given point in the ui). In practice, with code splitting and the asynchronicity of things, it's better to have it generated by jsenv during build and eventually adjusted, then reviewed by human.

## 3) You update the service worker

Likely `jsenv-sw.build_urls.js` got updated by jsenv. Or you updated `jsenv-sw.config.js` or `jsenv-sw.js` files.

## 4) Browser sees service worker has changed

Browser periodically fetches (every 24h) the url that was passed to `navigator.serviceWorker.register` and any scripts imported inside using `config.importScript`. It compare files and if any file has changed, the service worker is considered as updated. This process also happens every time `navigator.serviceWorker.register` is called. And it is called every time user loads or refresh the page.

- Browser spaws the new service worker code and trigger `install` on it.
- New service worker pre-cache urls in `config.urlsToCacheOnInstall`
- Browser waits for user to reload the page (or `skipWaiting` to be called)

> At this point browser tells us a new worker is installed and ready to be activated. Something in the user interface can say: There is a new version, reload page ?

- User reloads page
- Browser kills previous worker and trigger `activate` on the new worker.
- New worker delete cache of every url not in `config.urlsToCacheOnInstall`

> This is to ensure cache is cleaned to save disk space that is limited. This means any url not in `config.urlsToCacheOnInstall` must be fetched again. If that is not fine for you ensure `config.urlsToCacheOnInstall` contains all the urls you need.

## Usage

During build all urls used by your html file are known. This list of urls is put into a file in the build directory: `jsenv-sw.build_urls.js`.

Jsenv also copy `jsenv-sw.js` and `jsenv-sw.config.js` files into the build directory.

If a given build outputs exactly the same `jsenv-sw.build_urls.js` and you haven't modified `jsenv-sw.js` or `jsenv-sw.config.js` then your service worker is the same meaning user will use their current service worker implementation. Otherwise browser will see that something has changed and start the process to update the service worker.

All that means:

- if any of your file changes, `jsenv-sw.build_urls.js` changes, browser engages a service worker update.
- The way service worker updates favor cache reuse. As long as `config.cacheName` is the same between workers, cache will be reused and user will redownload only and exactly the files you modified.
- If you want to cache urls that does not appear in `jsenv-sw.build_urls.js`, add them manually in `jsenv-sw.config.js` inside `config.urlsToCacheOnInstall`.

## Notes about common scenarios

### Url missing in jsenv-sw.build_urls.js

If you load urls that are not explicitely referenced in your html/css/js/svg files they won't appear in `jsenv-sw.build_urls.js`. To fix that, add a reference in your file.

- Example of a reference to a file in js:

  ```js
  import url from "src/img.png"
  ```

- Example of a reference to a file in html:

  ```html
  <link rel="preload" href="./src/img.png" as="image" />
  ```

- Example of a reference to a file in css:

  ```css
  body {
    background-image: url("./src/img.png");
  }
  ```

You can also manually add urls into
or add them manually in `config.urlsToCacheOnInstall` inside `jsenv-sw.config.js`.

> Jsenv does not put external urls into `jsenv-sw.build_urls.js`. An external url contains an origin different from your website. This happens if you load a font from Google CDN for instance. An external url (that you want to cache) must be added manually to `jsenv-sw.config.js`.

## Cache not updated when service worker updates

Jsenv ensure every url referenced in your html/css/js is replaced by a unique url during the build.

> A unique url is an url like `./file-es34578.css` where `es34578` is an hash computed depending on the content of the file.

If you manually add an url to `config.urlsToCacheOnInstall` that is not unique as below:

```diff
- config.urlsToCacheOnInstall = self.jsenvBuildUrls
+ config.urlsToCacheOnInstall = [...self.jsenvBuildUrls, "https://fonts.googleapis.com/css2?family=Roboto"]
```

Then, cache for that url is reused even after service worker updates. When you do that, be sure to update `config.shouldReloadOnInstall` so that is returns true for these urls

```diff
- config.shouldReloadOnInstall = () => false
+ config.shouldReloadOnInstall = (response, request) => request.url === "https://fonts.googleapis.com/css2?family=Roboto"
```

It's simpler to keep that responsability to the service worker but you might need/want to control that from your code. It's possible to control service worker cache as shown below:

```js
import { sendMessageToServiceWorkerControllingPage } from "somewhere" // TODO: decide where this will be exposed

const result = await sendMessageToServiceWorkerControllingPage({
  action: "removeCacheKey",
  args: ["https://fonts.googleapis.com/css2?family=Roboto"],
})

// result can be:
//   - undefined: no service worker controlling the page
//   - false: there is no cache to remove for that url
//   - true: cache was removed
```
