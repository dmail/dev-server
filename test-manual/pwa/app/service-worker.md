# Jsenv service worker

Jsenv service worker goal is to make the website capable to work offline. Nothing more.

# Presentation

Here is an high level overview of what happens from the very first visit of a user to the moment you update your website and user gets the updated version of it.

## 1) User first visit

- Some code inside that page calls `navigator.serviceWorker.register("./jsenv-sw.js")`.
- Browser fetch/parse/execute `"./jsenv-sw.js"` and trigger `install` event on it.
- `jsenv-sw.js` pre fetch all urls declared in `self.urlsToCacheOnInstall` and puts them into browser cache. It puts them info a cache named after `self.cacheName`. See https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open. These url will be cached as long as this service worker lives.
- Browser trigger `activate` on `"./jsenv-sw.js"`

At this point service worker does not control the page. And **it's expected**. The intent of this service worker is that service worker will handle networks for the next visit. For that next visit, page loads instantly and could work offline.

> Using `skipWaiting` or `clients.claim()` to allow service worker to take control of the network requests as soon as it is activated it not the point of this service worker.

> Controlling page as soon as possible allow service worker to be aware of eventual request matching `self.shouldCacheRequest` and not in `self.urlsToCacheOnInstall`. But service worker would have missed most of them already as it happens in parallel to the user visiting the page. I prefer to see it like this: a service worker control a page from the very beginning or not at all. It's way simpler to reason about, predict and test.

## 2) User second visit

- Browser is now "controlled" by the service worker. Most network requests will be intercepted and served from cache.
- All request matching `self.shouldCacheRequest` will be served from cache if possible. If the url is not in cache (not in `self.urlsToCacheOnInstall`) it is fetched from network and put into cache. As a result page loads instantly without (or few depending on `self.urlsToCacheOnInstall`) requests to the network.

> It is theorically possible to generate `self.urlsToCacheOnInstall` automatically. We could start a headless browser and communicate to the service worker to start collecting urls, then start loading the site in an iframe and tell him when to stop when something happens in that iframe (like load event, or user reach a given point in the ui). In practice, with code splitting and the asynchronicity of things, it's better to have it generated by jsenv during build and eventually adjusted, then reviewed by human.

## 3) You update the service worker

You update `jsenv-sw.config.js` or `jsenv-sw.js` files.

## 4) Browser sees service worker has changed

Browser periodically fetches (every 24h) the url that was passed to `navigator.serviceWorker.register` and any scripts imported inside using `self.importScript`. It compare files and if any file has changed, the service worker is considered as updated. This process also happens every time `navigator.serviceWorker.register` is called. And it is called every time user loads or refresh the page.

- Browser spaws the new service worker code and trigger `install` on it.
- New service worker pre-cache urls in `self.urlsToCacheOnInstall`
- Browser waits for user to reload the page (or `skipWaiting` to be called)

> At this point browser tells us a new worker is installed and ready to be activated. Something in the user interface can say: There is a new version, reload page ?

- User reloads page
- Browser kills previous worker and trigger `activate` on the new worker.
- New worker delete cache of every url not in `self.urlsToCacheOnInstall`

> This is to ensure cache is cleaned to save disk space that is limited. This means any url not in `self.urlsToCacheOnInstall` must be fetched again. If that is not fine for you ensure `self.urlsToCacheOnInstall` contains all the urls you need.

## Usage

During build all urls used by your html file are known. This list of urls is put into a file in the build directory: `jsenv-sw.build_urls.js`.

Jsenv also copy `jsenv-sw.js` and `jsenv-sw.config.js` files into the build directory.

If a given build outputs exactly the same `jsenv-sw.build_urls.js` and you haven't modified `jsenv-sw.js` or `jsenv-sw.config.js` then your service worker is the same meaning user will use their current service worker implementation. Otherwise browser will see that something has changed and start the process to update the service worker.

All that means:

- if any of your file changes, `jsenv-sw.build_urls.js` changes, browser engages a service worker update.
- The way service worker updates favor cache reuse. As long as `self.cacheName` is the same between workers, cache will be reused and user will redownload only and exactly the files you modified.
- If you want to cache urls that does not appear in `jsenv-sw.build_urls.js`, add them manually in `jsenv-sw.config.js` inside `self.urlsToCacheOnInstall`.

Important notes:

- If you load urls that are not explicitely referenced in your html/css/js/svg files they won't appear in `jsenv-sw.build_urls.js`. To fix that, reference them somewhere or add them manually in `jsenv-sw.config.js` as suggested. Referencing an url looks like `import url from "src/img.png"` for a js file or `<link rel="preload" href="./src/img.png" />` for an html file.

- Jsenv does not put external urls into `jsenv-sw.build_urls.js`. An external url contains an origin different from your website. This happens if you load a font from Google CDN for instance. An external url (that you want to cache) must be added manually to `jsenv-sw.config.js`.
